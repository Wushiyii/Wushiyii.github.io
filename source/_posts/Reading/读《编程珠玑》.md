---
title: READ ---《编程珠玑》
date: 2019-12-08 16:10:03
tags: [READ,CODE]
categories: READ

---

总是听同事推荐，今天也买了本学习看看

<!-- more -->

#### 1.排序电话号码

一个文件包含有一千万条数据，每条数据都是7位数字，不用考虑磁盘大小，如何才能在1Mb的内存中尽量快的完成排序呢？

- 基于磁盘的归并排序，由于内存大小原因，可能需要好几天才能排序完，并且需要使用中间文件。
- 分趟进行排序，比如1Mb存储250000个号码，每次将排序好的号码输出到磁盘文件中，只要进行40次IO排序即可完成

> 那有没有不使用中间文件，且只要读取一次文件的排排序呢？

可以使用位图或者位向量来表示集合，比如表达一个集合`{2、5、8、12、16}`，就可以用:

` 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 0 1`来表达，有数值的部分即为1

##### 解决方案（Java实现）

```java
public static void main(String[] args) throws IOException {
        byte[] bitmap = new byte[1000000];

        //初始化位图，每位默认为0
        for (int i = 0, len = bitmap.length; i < len; i++) {
            bitmap[i] = (byte) 0;
        }

        //读取文件，并将位图对应下标修改
        FileInputStream fileInputStream = new FileInputStream("/Users/xxx/Desktop/input.txt");
        FileChannel inputChannel = fileInputStream.getChannel();
        ByteBuffer buffer = ByteBuffer.allocate(10);
        inputChannel.read(buffer);
        buffer.flip();
        while (buffer.hasRemaining()) {
            bitmap[(int) buffer.get()] = (byte) 0x01;
        }

        //输出文件
        FileOutputStream fileOutputStream = new FileOutputStream("/Users/xxx/Desktop/output.txt");
        final FileChannel outputChannel = fileOutputStream.getChannel();
        buffer.clear();
        for (int i = 0, len = bitmap.length; i < len; i++) {
            if (bitmap[i] == 0x01) buffer.put((byte) i);
        }
        buffer.flip();
        outputChannel.write(buffer);
    }
```



