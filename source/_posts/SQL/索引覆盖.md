---
title: Mysql执行计划的Extra信息
date: 2020-08-25 10:55:03
tags: [SQL]
categories: SQL
---
Mysql执行计划的Extra信息

<!-- more -->

### 数据准备

```sql
CREATE TABLE `oms_goods_item_inventory` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `warehouse_id` bigint(20) NOT NULL COMMENT '仓库库存id',
  `sku_id` bigint(20) NOT NULL COMMENT '商品sku编码',
  `goods_item_no` varchar(64) NOT NULL COMMENT '货号',
  `current_qty` int(11) NOT NULL DEFAULT '0' COMMENT '现货库存',
  `lock_qty` int(11) NOT NULL DEFAULT '0' COMMENT '锁定库存',
  `dispatch_qty` int(11) NOT NULL DEFAULT '0' COMMENT '调拨占用库存',
  `version` bigint(20) NOT NULL COMMENT '乐观锁版本号',
  `create_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uniq_warehouse_sku_goods_item_no` (`warehouse_id`,`sku_id`,`goods_item_no`)
) ENGINE=InnoDB AUTO_INCREMENT=1188 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='库存表';
```

插入10条测试数据

```sql
INSERT INTO `oms_goods_item_inventory` (`id`, `warehouse_id`, `sku_id`, `goods_item_no`, `barcode`, `current_qty`, `lock_qty`, `dispatch_qty`, `damage_qty`, `invalid_current_qty`, `invalid_current_dispatch_qty`, `version`, `create_at`, `update_at`) VALUES
('1186', '8', '559', '158763472600001', '2966_36_38NO NER1', '32', '2', '5', '7', '9', '11', '2', '2020-07-30 10:39:24', '2020-08-10 16:38:09'),
('1185', '8', '459', '158763472600001', '2966_36_38NO NERO', '30', '2', '0', '0', '0', '0', '2', '2020-07-30 10:38:55', '2020-08-05 15:44:12'),
('1184', '1', '559', '158763472600001', '2966_36_38NO NER1', '30', '2', '0', '0', '0', '0', '10', '2020-07-27 20:25:44', '2020-08-05 15:43:55'),
('1183', '2', '11477', '158894384600001', '1641701645235', '6', '6', '9', '0', '20', '24', '13', '2020-05-11 15:54:05', '2020-08-10 16:59:47'),
('1182', '4', '70385', '4979006070064', '4979006070064', '16', '2', '0', '4', '0', '0', '12', '2020-06-05 11:40:39', '2020-07-30 15:32:21'),
('1181', '5', '70385', '158885889700001', '4979006070064', '3', '3', '0', '2', '0', '0', '11', '2020-05-08 11:23:43', '2020-08-20 10:49:27'),
('1180', '7', '70818', '3473311421005', '3473311421005', '81', '77', '0', '6', '0', '0', '62', '2020-05-13 21:56:28', '2020-07-15 14:27:00'),
('1179', '9', '70820', '3473311320001', '3473311320001', '142', '50', '0', '33', '0', '0', '87', '2020-05-13 21:56:28', '2020-07-20 15:25:43'),
('1178', '15', '380', '158876899800001', '26R47613811R_38', '96', '95', '0', '1', '0', '0', '21', '2020-05-26 22:02:17', '2020-06-17 15:49:28'),
('1177', '35', '250', 'TSKU15', 'PW2S0F01RVH0JT_35', '0', '0', '10', '1', '0', '0', '48', '2020-05-25 09:59:45', '2020-06-29 08:14:17');
```



### 执行计划

- Using index

查询的列被索引覆盖，where条件命中的是符合最左匹配原则的索引

**语句：**

```sql
explain select warehouse_id from oms_goods_item_inventory where warehouse_id = 8
```

**结果：**

| id   | select_type | table                    | partitions | type | possible_keys                    | key                              | key_len | ref   | rows | filtered | Extra       |
| ---- | ----------- | ------------------------ | ---------- | ---- | -------------------------------- | -------------------------------- | ------- | ----- | ---- | -------- | ----------- |
| 1    | SIMPLE      | oms_goods_item_inventory |            | ref  | uniq_warehouse_sku_goods_item_no | uniq_warehouse_sku_goods_item_no | 8       | const | 4    | 100.00   | Using index |

- Using where; Using index

1. 查询的列被索引覆盖，但是where条件命中的不是最左匹配原则的索引，而是联合索引其中之一，意味着无法直接通过索引查询到符合条件的数据

**语句：**

```SQL
explain select warehouse_id from oms_goods_item_inventory where sku_id = 10
```

**结果：**

| id   | select_type | table                    | partitions | type  | possible_keys                    | key                              | key_len | ref  | rows | filtered | Extra                    |
| ---- | ----------- | ------------------------ | ---------- | ----- | -------------------------------- | -------------------------------- | ------- | ---- | ---- | -------- | ------------------------ |
| 1    | SIMPLE      | oms_goods_item_inventory |            | index | uniq_warehouse_sku_goods_item_no | uniq_warehouse_sku_goods_item_no | 532     |      | 157  | 10.00    | Using where; Using index |

2. 查询的列被索引覆盖，并且where条件是符合最左匹配原则索引的一个范围，同样意味着无法直接通过索引查询到符合条件的数据

**语句：**

```sql
explain select warehouse_id from oms_goods_item_inventory where warehouse_id > 1 and warehouse_id < 10;
```

**结果：**

| id   | select_type | table                    | partitions | type  | possible_keys                    | key                              | key_len | ref  | rows | filtered | Extra                    |
| ---- | ----------- | ------------------------ | ---------- | ----- | -------------------------------- | -------------------------------- | ------- | ---- | ---- | -------- | ------------------------ |
| 1    | SIMPLE      | oms_goods_item_inventory |            | range | uniq_warehouse_sku_goods_item_no | uniq_warehouse_sku_goods_item_no | 8       |      | 155  | 100.00   | Using where; Using index |

- Using where

查询的列**未被**索引覆盖，并且where条件未命中索引，或命中的是联合索引中非最左匹配原则的索引

**语句：**

```SQL
explain select current_qty from oms_goods_item_inventory where sku_id = 1;
explain select current_qty from oms_goods_item_inventory where current_qty = 10
```

**结果：**

| id   | select_type | table                    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| ---- | ----------- | ------------------------ | ---------- | ---- | ------------- | ---- | ------- | ---- | ---- | -------- | ----------- |
| 1    | SIMPLE      | oms_goods_item_inventory |            | ALL  |               |      |         |      | 157  | 10.00    | Using where |

- Using index condition

查询的列**未完全被**索引覆盖，并且where条件是符合最左匹配原则索引的范围查询

**语句：**

```sql
explain select * from oms_goods_item_inventory where warehouse_id > 1 and warehouse_id < 10;
```

**结果：**

| id   | select_type | table                    | partitions | type  | possible_keys                    | key                              | key_len | ref  | rows | filtered | Extra       |
| ---- | ----------- | ------------------------ | ---------- | ----- | -------------------------------- | -------------------------------- | ------- | ---- | ---- | -------- | ----------- |
| 1    | SIMPLE      | oms_goods_item_inventory |            | range | uniq_warehouse_sku_goods_item_no | uniq_warehouse_sku_goods_item_no | 8       |      | 21   | 100.00   | Using index |

- NULL

查询的列**未被**索引覆盖，并且where条件符合最左匹配原则索引。这意味着用到了索引，但是部分字段没被索引覆盖，需要回表查询，并不是纯粹用到索引。

语句：

```SQL
explain select * from oms_goods_item_inventory where warehouse_id = 1
```

结果：

| id   | select_type | table                    | partitions | type | possible_keys                    | key                              | key_len | ref   | rows | filtered | Extra |
| ---- | ----------- | ------------------------ | ---------- | ---- | -------------------------------- | -------------------------------- | ------- | ----- | ---- | -------- | ----- |
| 1    | SIMPLE      | oms_goods_item_inventory |            | ref  | uniq_warehouse_sku_goods_item_no | uniq_warehouse_sku_goods_item_no | 8       | const | 1    | 100.00   |       |

### 总结

1. Extra 为 `Using index`

查询的列被索引覆盖 **并且** where条件符合最左匹配原则 ，此时**无需回表**查询。

2. Extra 为`Using where;Using index`

出现`Using where Using index`意味着是通过索引扫描（或者表扫描）来实现sql语句执行的，即便是符合最左匹配原则的索引范围查找也有一点范围扫描的动作，不管是前非索引前导列引起的，还是非索引列查询引起的。

3. Extra 为 NULL

查询列存在未被索引覆盖 **并且** where条件符合最左匹配原则， 此时**需要回表**来找到未被索引覆盖的字段。