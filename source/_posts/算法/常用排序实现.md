---
title: 几种排序实现
date: 2020-02-14 20:28:03
tags: [Algorithm]
categories: Algorithm
---
Insert、Select、Merge、HeapSort...

<!-- more -->

#### 排序模板

排序中大量用到了如比较、交换、检查是否排序完成等操作，可以先抽象一个模板

```java
package chapter2;

public abstract class AbstractSort {

    public abstract void sort(int[] arr);

    protected boolean less(int a, int b) {
        return a < b;
    }

    protected void exchange(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    protected void show(int[] arr) {
        for (int comparable : arr) {
            System.out.print(comparable + " ");
        }
        System.out.println();
    }

    protected boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (less(arr[i], arr[i-1])) {
                return false;
            }
        }
        return true;
    }

    public void check(int[] arr) {
        sort(arr);
        show(arr);
        System.out.println(isSorted(arr));
    }

}

```



#### 选择排序

- 原理：首先，找到数组中最下的元素，将最小的元素和第一个元素交换。再次，将剩下元素中最小的元素和第二个元素交换，以此类推。
- 时间复杂度：(N-1) + (N-2) + ... + 2 + 1 ~ N^2/2 = O(N^2)
- 实现

```JAVA
public class CompareSort extends AbstractSort {

    @Override
    public void sort(int[] arr) {
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(arr[j], arr[min])) {
                    min = j;
                }
            }
            exchange(arr, i, min);
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[] {4,7,2,5,1,9,8,3,6,0,11,10,14,13,12};
        AbstractSort sort = new CompareSort();
        sort.check(arr);
    }
}
```

#### 插入排序

- 原理:首先从右往左遍历，判断第N个与第N-1个元素大小，若第N个小于第N-1，则互换位置。
- 时间复杂度：平均(N^2/4), 最坏(N^2/2),最好(N-1)。 最坏即为 O(N^2)
- 实现

```java
public class InsertionSort extends AbstractSort {

    @Override
    public void sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if (less(arr[j],arr[j-1])) {
                    exchange(arr, j, j-1);
                }
            }
        }
    }
}
```



#### 希尔排序

- 原理：插入排序对于大规模乱序的数组排序很慢，因为它之后交换相邻的元素，元素只能一个一个交换位置。希尔排序的思想是使数组中任意间隔h的元素都是有序的，每次以一个有序序列进行排序，并将间隔递减实现最终的整理。
- 时间复杂度：约O(N^3/2)
- 实现

```java
public class ShellSort extends AbstractSort {

    @Override
    public void sort(int[] arr) {
        int N = arr.length;
        int h = 1;
        while (h < N / 3) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h ; j = j - h) {
                    if (less(arr[j], arr[j - h])) {
                        exchange(arr, j, j-h);
                    }
                }
            }
            h = h / 3;
        }
    }
}
```



#### 归并排序

- 时间复杂度(O(Log(N)))

- 实现

- ```java
  public class MergeSort extends AbstractSort {
  
      private int[] aux;
  
      @Override
      public void sort(int[] arr) {
          aux = new int[arr.length];
          sort(arr, 0, arr.length - 1);
      }
  
      private void sort(int[] arr, int low, int high) {
          //将【low，high】 排序
          if (high <= low) return;
          int mid = low + (high - low) / 2;
          sort(arr, low, mid);
          sort(arr, mid+1, high);
          merge(arr, low, mid, high);
      }
  
      private void merge(int[] arr, int low, int mid, int high) {
          //将 【low， mid】、【mid+1， high】排序
          int i = low, j = mid + 1;
          for (int k = low; k <= high; k++) {
              aux[k] = arr[k];
          }
  
          for (int k = low; k <= high; k++) {
              if (i > mid) {
                  arr[k] = aux[j++];
              } else if (j > high) {
                  arr[k] = aux[i++];
              } else if (less(aux[j], aux[i])) {
                  arr[k] = aux[j++];
              } else {
                  arr[k] = aux[i++];
              }
  
          }
      }
  
      protected boolean less(int a, int b) {
          return a < b;
      }
  
      public static void main(String[] args) {
          int[] arr = new int[] {4,7,2,5,1,9,8,3,6,0,11,10,14,13,12};
          AbstractSort compareSort = new MergeSort();
          compareSort.check(arr);
      }
  }
  ```

#### 快速排序

- 时间复杂度(O(Log(N)))

- 实现

- ```java
  public class QuickSort extends AbstractSort {
  
      @Override
      public void sort(int[] arr) {
          sort(arr, 0, arr.length - 1);
      }
  
      private void sort(int[] arr, int low, int high) {
          if (low >= high) return;
          int j = partition(arr, low, high);
          sort(arr, low, j -1);
          sort(arr, j + 1, high);
      }
  
      private int partition(int[] arr, int low, int high) {
          //将数组切分为a[low... i-1], a[i], a[i+1...high]
          int i = low, j = high+1;
          int v = arr[i];
  
          while (true) {
              while (less(arr[++i], v)) {
                  if (i == high) break;
              }
              while (less(v, arr[--j])) {
                  if (j == low) break;
              }
              if (i >= j) break;
              exchange(arr, i, j);
          }
          exchange(arr, low, j);
          return j;
      }
    
    protected boolean less(int a, int b) {
          return a < b;
      }
  
      protected void exchange(int[] arr, int a, int b) {
          int temp = arr[a];
          arr[a] = arr[b];
          arr[b] = temp;
      }
  
      public static void main(String[] args) {
          int[] arr = new int[] {4,7,2,5,1,9,8,3,6,0,11,10,14,13,12};
          AbstractSort compareSort = new QuickSort();
          compareSort.check(arr);
      }
  
  }
  ```

#### 堆排序

- 原理： 利用二叉堆每次新增元素时，自动上浮或下沉元素，形成一个有序的集合。
- 时间复杂度(O(Log(N)))

