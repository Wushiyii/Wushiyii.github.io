---
title: 2PC、3PC
date: 2020-07-01 12:57:43
tags: [distribute]
categories: distribute
---

About distribute consistency

<!-- more -->

### 分布式一致性的问题

在一个分布式系统中，存在多个节点，而在每个节点中的数据都有可能存在不一致的情况。比如Mysql主从复制的原理是启一个异步线程定时从master节点拉取数据，这就存在数据短暂不一致的情况。

为了解决分布式一致问题，比较著名的算法协议有`2PC`（Two Phase Commit Protocol）、`3PC`（Three Phase Commit Protocol）、`Paxos`、`Raft`等。

### 分布式事务

> **分布式事务**是指在多个数据库之间通过一些分布式协议，实现支持跨数据库的事务支持

在分布式系统中，每个节点都是独立保持ACID的，节点与节点之间的数据并不能保持一致。如果需要保持一致性，那就需要在一次节点交互中进行事务的提交与回滚。但是每个节点只能控制自己的ACID，并不能知道对方的执行情况，这时候就需要一个事务协调者来统一调度各个节点的事务执行。

### XA规范

X/Open组织提出的DTP分布式模型，包括了四个部分

- 应用程序（AP）
- 事务管理器（TM）
- 资源管理器（RM）
- 通信资源管理器（CRM）

**XA**则是DTP模型中**TM**（事务管理器）与**RM**（资源管理器）通讯的接口规范。XA规范的目的是允许多个资源（如数据库，应用服务器，消息队列，等等）在同一事务中访问，这样可以使[ACID](https://zh.wikipedia.org/wiki/ACID)属性跨越应用程序而保持有效

XA的接口由数据库厂商提供，TM根据XA的接口来通知数据库事务的开始、结束、提交与回滚等。2PC、3PC就是根据这个思想衍生出来的。



### 2PC

>  **2PC**即**二阶段提交**（Two-phase Commit）是指在[计算机网络](https://zh.wikipedia.org/wiki/计算机网络)以及[数据库](https://zh.wikipedia.org/wiki/数据库)领域内，为了使基于[分布式系统](https://zh.wikipedia.org/wiki/分布式系统)架构下的所有节点在进行[事务](https://zh.wikipedia.org/wiki/数据库事务)提交时保持一致性而设计的一种[算法](https://zh.wikipedia.org/wiki/演算法)。

#### 第一阶段（准备阶段）

<img src="https://www.debugger.wiki/sourceimg/190710/c3c5e917447a583d83da4451c75c6eaa.jpg" alt="2pc-1" style="zoom:50%;" />

1. 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。
2. 参与者节点执行询问发起为止的所有事务操作，并将[Undo信息](https://zh.wikipedia.org/w/index.php?title=Undo信息&action=edit&redlink=1)和[Redo信息](https://zh.wikipedia.org/w/index.php?title=Redo信息&action=edit&redlink=1)写入日志。
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息。

#### 第二阶段（提交阶段）

- 参与者节点皆为成功

<img src="https://www.debugger.wiki/sourceimg/190710/e3ade8abfb29ee74e94b6112b7f096e1.jpg" alt="2pc-2" style="zoom:50%;" />

当协调者节点从所有参与者节点获得的响应消息都为"同意"时：

1. 协调者节点向所有参与者节点发出"正式提交"的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"完成"消息。
4. 协调者节点收到所有参与者节点反馈的"完成"消息后，完成事务。

- 当参与者节点存在失败

<img src="https://www.debugger.wiki/sourceimg/190710/b67c41099678e7bda4a88a5cf82f777a.jpg" alt="2pc-3" style="zoom:50%;" />

如果任一参与者节点在第一阶段返回的响应消息为"终止"，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：

1. 协调者节点向所有参与者节点发出"回滚操作"的请求。
2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"回滚完成"消息。
4. 协调者节点收到所有参与者节点反馈的"回滚完成"消息后，取消事务。

有时候，第二阶段也被称作**完成阶段**，因为无论结果怎样，协调者都必须在此阶段结束当前事务。

2PC看起来已经可以很好的解决分布式事务问题了，但是缺存在着几个缺点

>- 同步阻塞：事务执行过程中，所有节点都是事务阻塞的状态；当事务占用的资源有其他节点需要获取，其他节点也需要阻塞等待资源释放。
>- 单点故障：一旦协调者节点发生故障，参与者在事务开启时会一直阻塞，无法继续完成事务。
>- 数据不一致：在第二阶段时，协调者向各个参与者发送正式提交（commit）请求，此时有可能发生网络异常或协调者自身宕机等异常，导致只有部分参与者接受到提交指令，其他节点无法执行事务提交，这便出现了数据不一致现象。

### 3PC

> **3PC**即**三阶段提交**（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。
>
> 1、引入超时机制。同时在协调者和参与者中都引入超时机制。
> 2、在第一阶段和第二阶段中插入一个**准备阶段**。保证了在最后提交阶段之前各参与节点的状态是一致的。

与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，

3PC增加了超时机制，并且把2PC的准备阶段分为两部分。一共有了3个阶段`canCommit`、`preCommit`、doCommit`。

<img src="https://www.debugger.wiki/sourceimg/190710/b3df48b48db1c589a78ce8980eaff41a.jpg" alt="3pc" style="zoom:50%;" />

- canCommit

1. **事务询问**：**协调者**向**参与者**发送`canCommit`请求，询问是否可以执行事务
2. **响应反馈**：**参与者**收到`canCommit`请求，根据实际情况返回，如果其自身认为可以顺利执行事务，则返回`Yes`，并进入预提交状态。否则反馈`No`

- preCommit

如果**协调者**接受到所有**参与者**的反馈都为`Yes`，那就继续执行`preCommit`

1. **发送预提交请求**：协调者向参与者发送`preCommit`，并进入`prepared`阶段
2. **事务预提交**：参与者接受到`preCommit`请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
3. **响应反馈**：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

如果协调者在接受参与者反馈时，有部分出现超时或返回`No`，协调者将会执行事务中断

1. **发送事务中断请求**：协调者向所有参与者发送`abort`请求
2. **中断事务**：参与者收到来自协调者的`abort`请求之后（或超时之后，仍未收到协调者的请求，此为3PC新加的参与者超时），执行事务的中断。

- doCommit

此阶段进行真正的事务提交

1. **发送提交事务**：协调者接受到参与者发送到`ACK`响应，此时的事务状态将由预提交状态转为提交状态，并向所有参与者发送`doCommit`请求
2. **事务提交**：参与者接受到`doCommit`请求后，执行正式的事务提交，在完成事务后释放所有事务资源。
3. **响应反馈**：事务提交后，向协调者发送`ACK`响应
4. **完成事务**：协调者收到所有参与者的`ACK`响应后，完成事务

如果协调者最终在接受参与者反馈时，有部分出现超时或不是返回`ACK`，那么就将执行中断事务

1. **发送中断请求**：协调者向所有参与者发送`abort`请求
2. **事务回滚**：参与者接受到`abort`请求后，根据在`preCommit`阶段记录的undo信息来执行事务回滚，并在回滚完成后释放事务资源。
3. **响应反馈**：参与者完成事务回滚后，向协调者发送`ACK`响应
4. **中断事务**：协调者接受到参与者的反馈的`AKC`后，执行事务中断