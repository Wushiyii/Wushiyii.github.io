---
title: 深入理解JVM（一） ---- JVM的运行时数据区域
date: 2019-07-28 15:38:07
tags: [JAVA,JVM]
categories: JAVA
---
什么是`JVM`?`JVM`的内存模型又是怎么样的呢?

<!-- more -->

# 深入理解JVM（一）

### 什么是`JVM`？

`JVM`实际上就是java的虚拟机，即java virtual machine，它具有一个指令集并使用不同的存储区域，除此之外还负责执行指令、还要管理运行时数据、内存、寄存器等等。

`JVM`

### JVM的运行时数据区域

Java虚拟机会在执行java的过程中将它管理的内存划分为各个不同的区域，这些区域有着不同的用途，不同的生命周期，有的区域与JVM同周期，有的区域依赖于用户线程的周期，根据《Java虚拟机规范》,Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图。

![运行时数据区域](https://image-static.segmentfault.com/171/035/1710354522-5ad304bfcff05)

#### 程序计数器

程序计数器(Program Counter Register) 是一块较小的内存空间，在虚拟机的概念模型里，解释器工作时就是靠改变各个程序计数器中暂存的数值来进行代码逻辑的循环、跳转、处理异常、线程挂起、恢复等功能。

由于Java虚拟机的多线程实际上是通过线程轮流切换并分配执行时间来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都**只会执行一个线程内的指令**，因此每条线程都需要一个独立的程序计数器，这块内存为“内存私有“的内存。

#### Java虚拟机栈

与程序计数器一样，**java虚拟机栈也是线程私有的**，它的**生命周期与线程相同**。

虚拟机栈描述的是java方法执行的内存模型：每个方法在执行时都和创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法返回地址等，每一个方法**从调用直到执行完成**的过程，就对应一个栈帧在虚拟机中**入栈到出栈**的过程。

局部变量表存放了编译期可知的各种**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（`reference`类型，并不是对象本身，可能是一个对象引用指针）、**returnAddress类型**（指向一条字节码指令的地址）。局部变量表所需的内存空间在**编译器间完成分配**，当进入一个方法时，方法在栈帧中

需要分配多大的局部变量空间是完全确定，在方法运行期间不会改变局部变量表的大小。

在java虚拟机规范中，对java虚拟机栈规定了两种异常状况：

- 如果线程请求的栈深度超过虚拟机允许的深度，将抛出`StackOVerflowError`异常
- 如果虚拟机可以动态扩展，在扩展时如果无法申请到足够的内存(通过`DirectByteBuffe`计算是否可以向虚拟机外空间申请分配内存)，就会抛出`OutOfMemoryErro`r异常。

#### 本地方法栈

本地方法栈（Native Method Stack）与虚拟机栈的功能非常类似，区别在于虚拟机栈为java方法（字节码）服务，而本地方法栈为虚拟机调用的本地`native`方法服务。与虚拟机栈一样，本地方法栈也会抛出`StackOverFlowError`和`OutOfMemoryError`。

> 需要注意的是，java虚拟机规范中并没有强制规定本地方法栈中方法使用的语言、方式、数据结构，所以不同虚拟机会有不同的实现。`HotSpot`就直接将本地方法栈和虚拟机栈合二为一。

#### Java堆

对于大多数应用来说，Java堆（Java Heap）是Java虚拟机管理的最大一块内存。Java堆是**所有线程共享**的一块内存区域，在虚拟机启动时创建。Java堆的唯一目的就是存放对象实例，几乎所有对象的实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做”GC堆“（Garbage Collected Heap）。

- 从内存回收的角度上看，由于现代GC一般都采用**分代收集**算法，所以Java堆还可以细分为：新生代、老年代，再细致点有Eden、From Survivor、To Survivor。
- 从内存分配的角度上看，线程共享的java堆中可以划分多个线程私有的**分配缓冲区**（Thread Local Allocation Buffer，TLAB）

无论如何划分，无论哪个区域，实际上存储的仍然是java对象实例，不同的划分只是为了更好的回收、分配内存。

> Java堆可以处于物理上部连续的内存空间中，只要逻辑上是连续的即可。目前的主流虚拟机都支持扩展（通过-Xmx和-Xms控制），如果堆外也无法申请空间，则会抛出`OutOfMemoryError`异常

#### 方法区

方法区（Method Area）与Java堆一样，也是各个线程共享的内存区域，它用于存储已被加载的类信息、常量、静态变量、即使编译器（JIT）编译后的代码等数据。

`HotSpot`虚拟机使用GC分代的永久代实现了方法区，这样HotSpot可以垃圾收集可以像管理java堆一样管理方法区的内存，但是这并不意味着方法区就是永久代，在很多虚拟机中甚至没有永久代这个概念。垃圾收集在这个区域实际上是比较少出现的，方法区的主要回收目标是对常量池的回收和对类型的卸载。

> 如果方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常

#### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除类的版本、字段、方法、接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号的引用，这些内容将在类加载后进入方法区的运行时常量池中存放。

#### 直接内存

直接内存（Direct Memory）并不是java虚拟机运行时数据区的一部分，也不是java虚拟机中规定的内存范围，这部分实际上是堆外内存。

在Java1.4中新加入的NIO中，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Natice函数直接分配堆外内存，再通过java堆中的DirectByteBuffer对这块内存的引用进行操作。