<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>Recording the learning process</subtitle>
  <link href="https://www.wushiyi.top/atom.xml" rel="self"/>
  
  <link href="https://www.wushiyi.top/"/>
  <updated>2022-05-17T14:52:02.977Z</updated>
  <id>https://www.wushiyi.top/</id>
  
  <author>
    <name>Wushiyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ-Consumer拉取消费源码分析</title>
    <link href="https://www.wushiyi.top/2022/05/17/%E5%88%86%E5%B8%83%E5%BC%8F/consumer/"/>
    <id>https://www.wushiyi.top/2022/05/17/%E5%88%86%E5%B8%83%E5%BC%8F/consumer/</id>
    <published>2022-05-17T14:49:10.000Z</published>
    <updated>2022-05-17T14:52:02.977Z</updated>
    
    <content type="html"><![CDATA[<p>Consumer拉取消费源码分析</p><span id="more"></span><h3 id="创建并启动DefaultMQPushConsumer"><a href="#创建并启动DefaultMQPushConsumer" class="headerlink" title="创建并启动DefaultMQPushConsumer"></a>创建并启动<code>DefaultMQPushConsumer</code></h3><p>这是一段<code>RocketMq</code>自带的消费者启动测试代码，我们可以跟着这个流程一步步分析消费者做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建消费者</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置订阅关系</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;TagA || TagC&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册消费者实现</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">        ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动消费者</span></span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure><h4 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h4><p>首先从创建开始，<code>new DefaultMQPushConsumer(&quot;testConsumerGroup&quot;)</code>，一路往下回到这里，其中namespace默认为空，<code>AllocateMessageQueueStrategy</code>为消费策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String namespace, <span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span><br><span class="line"><span class="params">    AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">    <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">    <span class="built_in">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">    defaultMQPushConsumerImpl = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumerImpl</span>(<span class="built_in">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单构造，配置注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQPushConsumerImpl</span><span class="params">(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumer = defaultMQPushConsumer;</span><br><span class="line">    <span class="built_in">this</span>.rpcHook = rpcHook;</span><br><span class="line">    <span class="built_in">this</span>.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AllocateMessageQueueStrategy</code>里一共有6个实现,一般情况使用默认实现即可</p><ul><li><strong>AllocateMachineRoomNearby</strong>: 同机房分配策略</li><li><strong>AllocateMessageQueueAveragely</strong>: 平均分配（默认）</li><li><strong>AllocateMessageQueueAveragelyByCircle</strong>: 轮询分配</li><li><strong>AllocateMessageQueueByConfig</strong>: 指定配置消费</li><li><strong>AllocateMessageQueueByMachineRoom</strong>: 机房分配</li><li><strong>AllocateMessageQueueConsistentHash</strong>: 一致性哈希</li></ul><blockquote><p>设置订阅关系与注册消费者较简单，此处省略</p></blockquote><h4 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">//检查基本配置（消费组名称、订阅关系、消费线程数等）</span></span><br><span class="line">    <span class="built_in">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新赋值一遍订阅关系（重试消息的topic为:%Retry%+consumerGroup，订阅所有的tag）</span></span><br><span class="line">    <span class="built_in">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造MQ客户端实例</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(<span class="built_in">this</span>.defaultMQPushConsumer, <span class="built_in">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置消费进度服务</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="comment">//广播模式进度存在本地</span></span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">LocalFileOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//集群模式需要通知到broker</span></span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">RemoteBrokerOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="built_in">this</span>.offsetStore);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发消费服务</span></span><br><span class="line">    <span class="built_in">this</span>.consumeMessageService = <span class="keyword">new</span> <span class="title class_">ConsumeMessageConcurrentlyService</span>(<span class="built_in">this</span>, (MessageListenerConcurrently) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">    <span class="built_in">this</span>.consumeMessageService.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动实例</span></span><br><span class="line">    mQClientFactory.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新订阅关系（会通知到broker）</span></span><br><span class="line">    <span class="built_in">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//心跳通知broker</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//负载关系均衡</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mQClientFactory.start() 启动实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动netty客户端</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientAPIImpl.start();</span><br><span class="line">    <span class="comment">// 启动所有定时任务（更新topic路由信息、发送心跳、调整消费线程大小等）</span></span><br><span class="line">    <span class="built_in">this</span>.startScheduledTask();</span><br><span class="line">    <span class="comment">// 拉取消息服务</span></span><br><span class="line">    <span class="built_in">this</span>.pullMessageService.start();</span><br><span class="line">    <span class="comment">// 定时重负载均衡服务</span></span><br><span class="line">    <span class="built_in">this</span>.rebalanceService.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h4><p>上面在<code>consumer</code>启动的时候，也启动了<code>pullMessageService</code>，而这个service就是拉取消息的核心方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">//拉取请求阻塞队列，如果队列为空，则阻塞</span></span><br><span class="line">        <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestQueue.take();</span><br><span class="line">        <span class="built_in">this</span>.pullMessage(pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pullMessage</code>会调用多个方法，最后调用netty请求到<code>broker</code>，默认每次拉32个消息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造拉取请求</span></span><br><span class="line"><span class="type">PullMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PullMessageRequestHeader</span>();</span><br><span class="line">requestHeader.setConsumerGroup(<span class="built_in">this</span>.consumerGroup);</span><br><span class="line">requestHeader.setTopic(mq.getTopic());</span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line"></span><br><span class="line"><span class="type">PullResult</span> <span class="variable">pullResult</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(findBrokerResult.getBrokerAddr(),</span><br><span class="line">    requestHeader,</span><br><span class="line">    timeoutMillis,</span><br><span class="line">    communicationMode,</span><br><span class="line">    pullCallback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pullResult;</span><br></pre></td></tr></table></figure><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>在上面拉取消息的实现里，在拉取消息执行完成时，会调用一个callback执行处理，这里会将代码放入到一个<code>TreeMap</code>中，另有线程处理这些消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未拉取到消息会马上再拉一次</span></span><br><span class="line"><span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="literal">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把请求到入到消息处理队列中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dispatchToConsume</span> <span class="operator">=</span> processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据返回情况是否直接处理消息</span></span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="built_in">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">        pullResult.getMsgFoundList(),</span><br><span class="line">        processQueue,</span><br><span class="line">        pullRequest.getMessageQueue(),</span><br><span class="line">        dispatchToConsume);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拉取消息后，立即再次拉取消息</span></span><br><span class="line">    <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="built_in">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//马上拉取</span></span><br><span class="line">        DefaultMQPushConsumerImpl.<span class="built_in">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumeBatchSize</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//一次组装多个msg，可以配置批量消费消息数</span></span><br><span class="line">        List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                msgThis.add(msgs.get(total));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//异步处理,提交到线程池</span></span><br><span class="line">        <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(msgThis, processQueue, messageQueue);</span><br><span class="line">        <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面终于把拉取的消息缓存到了本地，下面开始执行消费。逻辑很简答，只是执行启动<code>consumer</code>时注册的listener。<br>这段就是业务代码执行消费的逻辑了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//构造消息context</span></span><br><span class="line">        <span class="type">ConsumeConcurrentlyContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeConcurrentlyContext</span>(messageQueue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用启动消费者时注册的listener执行消费逻辑</span></span><br><span class="line">        <span class="type">MessageListenerConcurrently</span> <span class="variable">listener</span> <span class="operator">=</span> ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.messageListener;</span><br><span class="line">        <span class="type">ConsumeConcurrentlyStatus</span> <span class="variable">status</span> <span class="operator">=</span> listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">        <span class="comment">//判断status消费状态，执行消费成功、重消费等逻辑 </span></span><br><span class="line">        <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行消费消息后的操作</span></span><br><span class="line">        <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">            ConsumeMessageConcurrentlyService.<span class="built_in">this</span>.processConsumeResult(status, context, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费完成后的处理"><a href="#消费完成后的处理" class="headerlink" title="消费完成后的处理"></a>消费完成后的处理</h4><p>在上面我们看到，消息已经交给业务代码执行，执行完成后调用了<code>processConsumeResult</code>，这个函数主要是把本地缓存的临时消息清除，以及更新<code>broker</code>端的消息完成<code>offset</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConsumeResult</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理消费失败的消息，会将消费失败的消息发给broker</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">        <span class="type">MessageExt</span> <span class="variable">msg</span> <span class="operator">=</span> consumeRequest.getMsgs().get(i);</span><br><span class="line">        <span class="comment">//通知broker消费失败消息</span></span><br><span class="line">        <span class="built_in">this</span>.sendMessageBack(msg, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从消息树中移除消息</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新消费成功便宜量offset</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeMessage代码比较简单，就是根据每一个msg的offset，从消息树中remove</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> &#123;</span><br><span class="line">    <span class="comment">//开启读写锁</span></span><br><span class="line">    <span class="comment">//把消息从消息树中去除，无论成功失败</span></span><br><span class="line">    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">        <span class="type">MessageExt</span> <span class="variable">prev</span> <span class="operator">=</span> msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新本地的消费进度，有另一个线程会执行，而这个线程在consumer启动的时候就启动了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateOffset</span><span class="params">(MessageQueue mq, <span class="type">long</span> offset, <span class="type">boolean</span> increaseOnly)</span> &#123;</span><br><span class="line">    <span class="comment">//更新本地的消费进度偏移量</span></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">offsetOld</span> <span class="operator">=</span> <span class="built_in">this</span>.offsetTable.get(mq);</span><br><span class="line">    MixAll.compareAndIncreaseOnly(offsetOld, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知broker消费进度"><a href="#通知broker消费进度" class="headerlink" title="通知broker消费进度"></a>通知broker消费进度</h4><p>在启动消费者时，有一个<code>startScheduledTask()</code>,这个方法会开启多个线程执行任务，其中有一个定时保存消费进度的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt;</span><br><span class="line">    MQClientInstance.<span class="built_in">this</span>.persistAllConsumerOffset(),</span><br><span class="line">    <span class="number">1000</span> * <span class="number">10</span>, </span><br><span class="line">    <span class="built_in">this</span>.clientConfig.getPersistConsumerOffsetInterval(), </span><br><span class="line">    TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>而这个线程最终会调用<code>offsetStore.persistAll()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">persistAll</span><span class="params">(Set&lt;MessageQueue&gt; mqs)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//消费者监听的每一个队列</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class="built_in">this</span>.offsetTable.entrySet()) &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">offset</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通知broker更新消费者的消费进度</span></span><br><span class="line">        <span class="built_in">this</span>.updateConsumeOffsetToBroker(mq, offset.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此结束了消息消费流程，里面删了些部分主流程不用关心的代码，总体而言<code>consumer</code>的代码较为简单，比较复杂的tcp交互、拉取等待的逻辑都在<code>broker</code>完成了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Consumer拉取消费源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
    <category term="MQ" scheme="https://www.wushiyi.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-Broker存储消息源码分析</title>
    <link href="https://www.wushiyi.top/2022/05/08/%E5%88%86%E5%B8%83%E5%BC%8F/broker/"/>
    <id>https://www.wushiyi.top/2022/05/08/%E5%88%86%E5%B8%83%E5%BC%8F/broker/</id>
    <published>2022-05-08T07:05:22.000Z</published>
    <updated>2022-05-08T13:20:28.464Z</updated>
    
    <content type="html"><![CDATA[<p>Broker存储消息源码分析</p><span id="more"></span><h1 id="broker-保存消息流程"><a href="#broker-保存消息流程" class="headerlink" title="broker 保存消息流程"></a>broker 保存消息流程</h1><p>首先是接收请求消息的入口，与<code>producer</code>发送消息接收返回的代码一致，不过请求类型为服务端主动请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> msg;</span><br><span class="line">    <span class="comment">//请求分为两类： 一类是服务端主动发送的请求，一类是服务端发送响应的请求</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">        <span class="comment">//服务端主动发送</span></span><br><span class="line">        <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">            processRequestCommand(ctx, cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//服务端响应的请求</span></span><br><span class="line">        <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">            processResponseCommand(ctx, cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码大概意思是调用业务线程池处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequestCommand</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand cmd)</span> &#123;</span><br><span class="line">    <span class="comment">//从处理器table中根据请求码获取到处理器， pair为默认请求处理器</span></span><br><span class="line">    <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="literal">null</span> == <span class="built_in">this</span>.processorTable.get(cmd.getCode()) ? <span class="built_in">this</span>.defaultRequestProcessor : matched;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">opaque</span> <span class="operator">=</span> cmd.getOpaque();</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//消息执行完的回调（其实就是调用Netty把返回值发送回去）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">RemotingResponseCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemotingResponseCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(RemotingCommand response)</span> &#123;</span><br><span class="line">                        doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd, response);</span><br><span class="line">                        <span class="comment">//非oneway类型请求，会有响应</span></span><br><span class="line">                        <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                            response.setOpaque(opaque);</span><br><span class="line">                            response.markResponseType();</span><br><span class="line">                            <span class="comment">//发送响应消息</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//调用执行器处理请求</span></span><br><span class="line">                <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//执行回调</span></span><br><span class="line">                callback.callback(response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">        <span class="comment">//这里才是调用线程池执行处理请求的地方</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RequestTask</span> <span class="variable">requestTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestTask</span>(run, ctx.channel(), cmd);</span><br><span class="line">        pair.getObject2().submit(requestTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>producer</code>在发送消息的时候，指明了消息code是<code>10</code>（SEND_MESSAGE），在<code>BrokerController.registerProcessor()</code>这个方法里面就有<code>10</code>对应的处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SendMessageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">SendMessageProcessor</span> <span class="variable">sendProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMessageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    sendProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line">    sendProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始是<code>broker</code>中处理消息的核心逻辑了，代码较多，会分多个小块解析。</p><h3 id="DefaultMessageStore保存消息入口"><a href="#DefaultMessageStore保存消息入口" class="headerlink" title="DefaultMessageStore保存消息入口"></a>DefaultMessageStore保存消息入口</h3><p>调用入口是<code>DefaultMessageStore.putMessage()</code>，这个在<code>SendMessageProcessor.processRequest()</code>里面处理消息的地方可以找到。<br>这段代码较简单，主要是校验功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(MessageExtBrokerInner msg)</span> &#123;</span><br><span class="line">    <span class="comment">////检擦当前broker状态（是否启动、是否为Slave、是否可写、是否繁忙）</span></span><br><span class="line">    <span class="type">PutMessageStatus</span> <span class="variable">checkStoreStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.checkStoreStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查消息是否合法</span></span><br><span class="line">    <span class="type">PutMessageStatus</span> <span class="variable">msgCheckStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.checkMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用commitLog服务存储消息</span></span><br><span class="line">    CompletableFuture&lt;PutMessageResult&gt; putResultFuture = <span class="built_in">this</span>.commitLog.asyncPutMessage(msg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitLog执行保存消息"><a href="#commitLog执行保存消息" class="headerlink" title="commitLog执行保存消息"></a>commitLog执行保存消息</h3><p>主要为调用mmap服务保存消息，以及处理刷盘、主从同步等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋锁</span></span><br><span class="line">    putMessageLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取最新的mmap文件，若不存在则创建一个</span></span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); </span><br><span class="line">        <span class="comment">//append消息到mmap对象</span></span><br><span class="line">        <span class="type">AppendMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> mappedFile.appendMessage(msg, <span class="built_in">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="comment">//。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//flush刚刚append到mmap文件上到消息</span></span><br><span class="line">    CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复制到其他机器（DLedger或者简单主从同步）</span></span><br><span class="line">    CompletableFuture&lt;PutMessageStatus&gt; replicaResultFuture = submitReplicaRequest(result, msg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码较多，mmap等地方会比较复杂，下面会进行拆分</p></blockquote><h3 id="获取-创建-Mmap文件"><a href="#获取-创建-Mmap文件" class="headerlink" title="获取/创建 Mmap文件"></a>获取/创建 Mmap文件</h3><p>上文中<code>getLastMappedFile(0)</code>这个函数，会尝试获取当前mmap文件列表的最后一个文件，若获取不到则会创建文件并生产mmap映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> startOffset, <span class="type">boolean</span> needCreate)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件大小偏移量，初识时为0</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">createOffset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试获取最后一个mmap文件</span></span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFileLast</span> <span class="operator">=</span> getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若文件不存在，则偏移量为: 0 +1073741824 = 1073741824; (1G = 1024 * 1024 * 1024)</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFileLast != <span class="literal">null</span> &amp;&amp; mappedFileLast.isFull()) &#123;</span><br><span class="line">        createOffset = mappedFileLast.getFileFromOffset() + <span class="built_in">this</span>.mappedFileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (createOffset != -<span class="number">1</span> &amp;&amp; needCreate) &#123;</span><br><span class="line">        <span class="comment">//创建的文件路径，如 /home/data/store/00000000001073741824</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nextFilePath</span> <span class="operator">=</span> <span class="built_in">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一个待创建的文件路径 如 /home/data/store/00000000002147483648</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nextNextFilePath</span> <span class="operator">=</span> <span class="built_in">this</span>.storePath + File.separator</span><br><span class="line">                + UtilAll.offset2FileName(createOffset + <span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">        <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有指定分配mmap文件的服务，则使用指定的服务创建（这个服务可以异步处理分配内存）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.allocateMappedFileService != <span class="literal">null</span>) &#123;</span><br><span class="line">            mappedFile = <span class="built_in">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line">                    nextNextFilePath, <span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认创建方式</span></span><br><span class="line">            mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(nextFilePath, <span class="built_in">this</span>.mappedFileSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mappedFile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath, String nextNextFilePath, <span class="type">int</span> fileSize)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//可以允许请求分配的请求数（其实就是bufferPool数量限制），默认为2原因是要分配当前文件和下一个文件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">canSubmitRequests</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.messageStore.getMessageStoreConfig().isFastFailIfNoBufferInStorePool()</span><br><span class="line">            &amp;&amp; BrokerRole.SLAVE != <span class="built_in">this</span>.messageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">            <span class="comment">//最大同时创建buffer数 - 等待处理分配请求数 = 可分配数</span></span><br><span class="line">            canSubmitRequests = <span class="built_in">this</span>.messageStore.getTransientStorePool().availableBufferNums() - <span class="built_in">this</span>.requestQueue.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许分配数小于等于0，则直接返回不让分配</span></span><br><span class="line">    <span class="keyword">if</span> (canSubmitRequests &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestTable.remove(nextFilePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//允许分配，把分配请求放入优先队列中（文件名小的优先）</span></span><br><span class="line">    <span class="type">AllocateRequest</span> <span class="variable">nextReq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AllocateRequest</span>(nextFilePath, fileSize);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">offerOK</span> <span class="operator">=</span> <span class="built_in">this</span>.requestQueue.offer(nextReq);</span><br><span class="line">    canSubmitRequests--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出当前文件的分配请求</span></span><br><span class="line">    <span class="type">AllocateRequest</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.requestTable.get(nextFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CountDownLatch超时5秒，另一边有监听优先队列的实现</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">waitOK</span> <span class="operator">=</span> result.getCountDownLatch().await(waitTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (waitOK) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestTable.remove(nextFilePath);</span><br><span class="line">        <span class="keyword">return</span> result.getMappedFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这一段，解析了broker如何拿到mmap文件和构造创建mmapd请求队列，下面开始讲执行监听mmap请求队列到实现<br><code>AllocateMappedFileService</code>实现了<code>Runnable</code>，而其中的<code>run()</code>方法则会在这个服务启动的时候执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//只要服务不停止，则一直进行mmap操作</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped() &amp;&amp; <span class="built_in">this</span>.mmapOperation()) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">mmapOperation</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列里的消息</span></span><br><span class="line">    <span class="type">AllocateRequest</span> <span class="variable">req</span> <span class="operator">=</span> <span class="built_in">this</span>.requestQueue.take();</span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    MappedFile mappedFile;</span><br><span class="line">    <span class="keyword">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">        <span class="comment">//使用SPI方式加载MappedFile服务</span></span><br><span class="line">        mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行mmap文件初始化与映射</span></span><br><span class="line">        mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//与上面类似，都是调用mapperFile里面的init方法</span></span><br><span class="line">        mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(req.getFilePath(), req.getFileSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预热mmap文件，一般情况不开</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFile.getFileSize() &gt;= <span class="built_in">this</span>.messageStore.getMessageStoreConfig()</span><br><span class="line">            .getMappedFileSizeCommitLog()</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            <span class="built_in">this</span>.messageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        mappedFile.warmMappedFile(<span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushDiskType(),</span><br><span class="line">                <span class="built_in">this</span>.messageStore.getMessageStoreConfig().getFlushLeastPagesWhenWarmMapedFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.setMappedFile(mappedFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行mmap，代码不多，主要是NIO干活</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="built_in">this</span>.file = <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="built_in">this</span>.fileFromOffset = Long.parseLong(<span class="built_in">this</span>.file.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查文件上级目录，无目录则创建</span></span><br><span class="line">    ensureDirOK(<span class="built_in">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造随机读写对象</span></span><br><span class="line">    <span class="built_in">this</span>.fileChannel = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="built_in">this</span>.file, <span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line">    <span class="comment">//使用fileChannel执行map映射</span></span><br><span class="line">    <span class="built_in">this</span>.mappedByteBuffer = <span class="built_in">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mmap存储执行append消息"><a href="#mmap存储执行append消息" class="headerlink" title="mmap存储执行append消息"></a>mmap存储执行append消息</h3><p>上面讲了一大堆铺垫，其实最终干活的还是mmap映射对象。<code>mappedFile.appendMessage()</code>这段是发送消息的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="type">int</span> maxBlank,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询topic+queueID组合下的offset</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">queueOffset</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.topicQueueTable.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化消息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] propertiesData =</span><br><span class="line">            msgInner.getPropertiesString() == <span class="literal">null</span> ? <span class="literal">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各种字段长度</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">propertiesLength</span> <span class="operator">=</span> propertiesData == <span class="literal">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">topicLength</span> <span class="operator">=</span> topicData.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> msgInner.getBody() == <span class="literal">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">msgLen</span> <span class="operator">=</span> calMsgLength(msgInner.getSysFlag(), bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录消息的各个字段与长度到一个buffer中</span></span><br><span class="line">        <span class="built_in">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</span><br><span class="line">        <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        <span class="built_in">this</span>.msgStoreItemMemory.putInt(msgLen);</span><br><span class="line">        <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">        <span class="built_in">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</span><br><span class="line">        <span class="comment">// xxx 10几个字段设置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入消息到buffer中</span></span><br><span class="line">        byteBuffer.put(<span class="built_in">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="type">AppendMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line">            msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="built_in">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span>:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">// 普通消息和事务消息到提交消息、记录存储的偏移量</span></span><br><span class="line">                CommitLog.<span class="built_in">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="同步刷盘-amp-amp-异步刷盘"><a href="#同步刷盘-amp-amp-异步刷盘" class="headerlink" title="同步刷盘 &amp;&amp; 异步刷盘"></a>同步刷盘 &amp;&amp; 异步刷盘</h3><p>至此，消息终于存放到了buffer中，但是消息是如何落盘的？开启了同步刷屏的实现在哪？<br>在上面的<code>asyncPutMessage</code>中，最下面执行了<code>submitFlushRequest</code>，而如果配置了同步刷盘，这个逻辑就会被执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageStatus&gt; <span class="title function_">submitFlushRequest</span><span class="params">(AppendMessageResult result, MessageExt messageExt)</span> &#123;</span><br><span class="line">    <span class="comment">// 同步刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">GroupCommitService</span> <span class="variable">service</span> <span class="operator">=</span> (GroupCommitService) <span class="built_in">this</span>.flushCommitLogService;</span><br><span class="line">        <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            <span class="type">GroupCommitRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupCommitRequest</span>(result.getWroteOffset() + result.getWroteBytes(),</span><br><span class="line">                    <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            service.putRequest(request);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步刷盘</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupCommitService</span> <span class="keyword">extends</span> <span class="title class_">FlushCommitLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">//这边使用CountDownLatch阻塞获取请求，获取到了会调用onWaitEnd()切换请求模式</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交请求</span></span><br><span class="line">            <span class="built_in">this</span>.doCommit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//切换读写请求</span></span><br><span class="line">            <span class="built_in">this</span>.swapRequests();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再提交一次，这一次模式换了一个</span></span><br><span class="line">        <span class="built_in">this</span>.doCommit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//执行flush</span></span><br><span class="line">                CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前mmap文件可以执行flush操作， hold方法调用意味着占用这个flush操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAbleToFlush(flushLeastPages) &amp;&amp; <span class="built_in">this</span>.hold()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//直接调用mmap的force方法刷到磁盘</span></span><br><span class="line">        <span class="keyword">if</span> (writeBuffer != <span class="literal">null</span> || <span class="built_in">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.fileChannel.force(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mappedByteBuffer.force();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放占用</span></span><br><span class="line">        <span class="built_in">this</span>.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是同步刷盘的逻辑，异步刷盘又有何不同呢？异步刷盘调用的服务是<code>FlushCommitLogService</code>，调用方式与上面大同小异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlushRealTimeService</span> <span class="keyword">extends</span> <span class="title class_">FlushCommitLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">//其实就是每隔xxx秒，刷一次</span></span><br><span class="line">            <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.waitForRunning(interval);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>至此，<code>broker</code>的消息存储代码已完结，里面删除了很多分散注意力的代码，详情可以参考源代码再看一遍，有很多并发的手段（通知、信号量、异步线程等）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Broker存储消息源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
    <category term="MQ" scheme="https://www.wushiyi.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-Producer发送消息源码分析</title>
    <link href="https://www.wushiyi.top/2022/05/06/%E5%88%86%E5%B8%83%E5%BC%8F/Producer/"/>
    <id>https://www.wushiyi.top/2022/05/06/%E5%88%86%E5%B8%83%E5%BC%8F/Producer/</id>
    <published>2022-05-06T15:03:01.000Z</published>
    <updated>2022-05-06T15:09:48.598Z</updated>
    
    <content type="html"><![CDATA[<p>Producer发送消息源码分析</p><span id="more"></span><h3 id="发送消息过程"><a href="#发送消息过程" class="headerlink" title="发送消息过程"></a>发送消息过程</h3><p>发送的入口主要是<code>DefaultMqProducer.send()</code>,这个方法经过一层层包装，会调用到<code>DefaultMQProducerImpl.sendDefaultImpl()</code>,下面简单分析下这些代码做了什么事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(Message msg, </span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SendCallback sendCallback, </span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确认服务状态正常</span></span><br><span class="line">        <span class="built_in">this</span>.makeSureStateOK();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验消息(topic是否合法，是否缺失body等)</span></span><br><span class="line">        Validators.checkMessage(msg, <span class="built_in">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机生产一个请求ID</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">invokeID</span> <span class="operator">=</span> random.nextLong();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始、结束时间等</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTimestampFirst</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">beginTimestampPrev</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimestamp</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据topic查询namesrv上的路由信息，返回结果为某个Topic在某个broker下，broker下又有哪些brokerId和地址，以及broker下的queue分布、配置</span></span><br><span class="line">        <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (topicPublishInfo != <span class="literal">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">callTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//是否超时</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//broker中的队列</span></span><br><span class="line">            <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//是否异常</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//发送结果</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步请求默认请求次数为3，要有重试功能首先得开启</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">timesTotal</span> <span class="operator">=</span> communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//请求次数记录</span></span><br><span class="line">            String[] brokersSent = <span class="keyword">new</span> <span class="title class_">String</span>[timesTotal];</span><br><span class="line">            <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//上一次发送的broker名称（只会在3次重试内出现）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">lastBrokerName</span> <span class="operator">=</span> <span class="literal">null</span> == mq ? <span class="literal">null</span> : mq.getBrokerName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//随机取一条队列（随机数与队列长度取模作为index，当然也要考虑排除上一次路由的broker名称）</span></span><br><span class="line">                <span class="type">MessageQueue</span> <span class="variable">mqSelected</span> <span class="operator">=</span> <span class="built_in">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">                <span class="keyword">if</span> (mqSelected != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mq = mqSelected;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();<span class="comment">//记录当前第n次发送时对应的broker名称</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            msg.setTopic(<span class="built_in">this</span>.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//判断超时</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                        <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                            callTimeout = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//执行发送消息</span></span><br><span class="line">                        sendResult = <span class="built_in">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//如果为同步模式，会直接返回结果</span></span><br><span class="line">                        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> SYNC:</span><br><span class="line">                                <span class="keyword">return</span> sendResult;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处主要逻辑是组装消息（Header、事务消息tag等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mq为随机选的一个队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brokerAddr</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="type">SendMessageContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息原数据</span></span><br><span class="line">    <span class="type">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//非批量消息，需要生成一个唯一ID</span></span><br><span class="line">        <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">            MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sysFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">msgBodyCompressed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果消息大小大于4k，会尝试进行压缩</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">            sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">            msgBodyCompressed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//事务消息标识</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tranMsg</span> <span class="operator">=</span> msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">        <span class="keyword">if</span> (tranMsg != <span class="literal">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">            sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息发送hook(发送前、后执行的回调)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">            <span class="comment">//。。。 组装context等</span></span><br><span class="line">            <span class="built_in">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装消息header头信息</span></span><br><span class="line">        <span class="type">SendMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMessageRequestHeader</span>();</span><br><span class="line">        requestHeader.setProducerGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">        requestHeader.setTopic(msg.getTopic());</span><br><span class="line">        requestHeader.setDefaultTopic(<span class="built_in">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">        requestHeader.setDefaultTopicQueueNums(<span class="built_in">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">        requestHeader.setSysFlag(sysFlag);</span><br><span class="line">        requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">        requestHeader.setFlag(msg.getFlag());</span><br><span class="line">        requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">        requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">        requestHeader.setUnitMode(<span class="built_in">this</span>.isUnitMode());</span><br><span class="line">        requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">        <span class="comment">//如果为重试的消息，则发送重试次数、最大重试次数</span></span><br><span class="line">        <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">            <span class="keyword">if</span> (reconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">                requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">maxReconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">            <span class="keyword">if</span> (maxReconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">                requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                <span class="type">Message</span> <span class="variable">tmpMessage</span> <span class="operator">=</span> msg;</span><br><span class="line">                <span class="comment">//如果消息压缩过，需要clone到临时对象，把原值还原</span></span><br><span class="line">                <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                    tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                    msg.setBody(prevBody);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="variable">costTimeAsync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                <span class="comment">//调用Netty客户端接口，发送消息</span></span><br><span class="line">                sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                    brokerAddr,</span><br><span class="line">                    mq.getBrokerName(),</span><br><span class="line">                    tmpMessage,</span><br><span class="line">                    requestHeader,</span><br><span class="line">                    timeout - costTimeAsync,</span><br><span class="line">                    communicationMode,</span><br><span class="line">                    sendCallback,</span><br><span class="line">                    topicPublishInfo,</span><br><span class="line">                    <span class="built_in">this</span>.mQClientFactory,</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                    context,</span><br><span class="line">                    <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">            <span class="keyword">case</span> SYNC:</span><br><span class="line">                <span class="comment">//同步消息相比异步，不用传callback进去</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">costTimeSync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                    brokerAddr,</span><br><span class="line">                    mq.getBrokerName(),</span><br><span class="line">                    msg,</span><br><span class="line">                    requestHeader,</span><br><span class="line">                    timeout - costTimeSync,</span><br><span class="line">                    communicationMode,</span><br><span class="line">                    context,</span><br><span class="line">                    <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行发送消息后的回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">            context.setSendResult(sendResult);</span><br><span class="line">            <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sendResult;</span><br></pre></td></tr></table></figure><p>下面看一看<code>getMQClientAPIImpl().sendMessage()</code>这一块的实现，主要就是区分三种请求方式，执行不同的发送方法（但是后面的发送方法又耦合在一起，迷惑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//其实就是请求体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通消息和批量消息走不同的RequestCode</span></span><br><span class="line">    <span class="keyword">if</span> (sendSmartMsg || msg <span class="keyword">instanceof</span> MessageBatch) &#123;</span><br><span class="line">        <span class="type">SendMessageRequestHeaderV2</span> <span class="variable">requestHeaderV2</span> <span class="operator">=</span> SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);</span><br><span class="line">        request = RemotingCommand.createRequestCommand(msg <span class="keyword">instanceof</span> MessageBatch ? RequestCode.SEND_BATCH_MESSAGE : RequestCode.SEND_MESSAGE_V2, requestHeaderV2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//又组装一遍报文到RequestCommand对象中</span></span><br><span class="line">        request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br><span class="line">    &#125;</span><br><span class="line">    request.setBody(msg.getBody());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三种执行方式</span></span><br><span class="line">    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">            <span class="comment">//直接发送，不关心返回</span></span><br><span class="line">            <span class="built_in">this</span>.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">//异步请求、会在请求完成后处理callback</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">times</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">            <span class="type">long</span> <span class="variable">costTimeAsync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="built_in">this</span>.sendMessageAsync(addr, brokerName, msg, timeoutMillis - costTimeAsync, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line">                retryTimesWhenSendFailed, times, context, producer);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">case</span> SYNC:</span><br><span class="line">            <span class="comment">//同步请求，利用CountDownLatch阻塞请求，直到对方返回或超时</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">costTimeSync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sendMessageSync(addr, brokerName, msg, timeoutMillis - costTimeSync, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种请求方式里重点看一下同步请求,代码照样删了些不重要的</p><blockquote><p>下面代码只写了发送以及等待，哪里触发<code>CountDownLatch</code>释放呢？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造TCP返回对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ResponseFuture</span> <span class="variable">responseFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseFuture</span>(channel, opaque, timeoutMillis, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//以唯一请求码为key放入一个临时map中</span></span><br><span class="line"><span class="built_in">this</span>.responseTable.put(opaque, responseFuture);</span><br><span class="line"><span class="keyword">final</span> <span class="type">SocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> channel.remoteAddress();</span><br><span class="line"><span class="comment">//直接调用netty的发送方法</span></span><br><span class="line">channel.writeAndFlush(request).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.isSuccess()) &#123;</span><br><span class="line">            responseFuture.setSendRequestOK(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseFuture.setSendRequestOK(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过CountDownLatch阻塞等待请求结果</span></span><br><span class="line"><span class="type">RemotingCommand</span> <span class="variable">responseCommand</span> <span class="operator">=</span> responseFuture.waitResponse(timeoutMillis);</span><br><span class="line"><span class="keyword">return</span> responseCommand;</span><br></pre></td></tr></table></figure><p>上面提了什么时候触发<code>CountDownLatch</code>的释放，其实熟悉Netty的话就会在client的pipeline中找到答案<br>在<code>NettyRemotingClient.java</code>中，pipeline中加了几个处理器，大概为编码、解码、空闲关联、连接关联以及最重要的请求处理器(<code>NettyClientHandler</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(</span><br><span class="line">                defaultEventExecutorGroup,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NettyEncoder</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NettyDecoder</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, nettyClientConfig.getClientChannelMaxIdleTimeSeconds()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NettyConnectManageHandler</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br></pre></td></tr></table></figure><p>其中<code>NettyClientHandler</code>继承了<code>SimpleChannelInboundHandler</code>，意为只处理入站请求。里面的<code>channelRead0</code>就是处理请求的入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RemotingCommand&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        processMessageReceived(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> msg;</span><br><span class="line">    <span class="comment">//请求分为两类： 一类是服务端主动发送的请求，一类是服务端发送响应的请求</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">        <span class="comment">//服务端主动发送</span></span><br><span class="line">        <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">            processRequestCommand(ctx, cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//服务端响应的请求</span></span><br><span class="line">        <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">            processResponseCommand(ctx, cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端主动发送的请求：这类看client处于哪个服务中，例如在<code>namesrv</code>中<code>producer</code>过来拉取topic路由。</li><li>服务端返回响应的请求：代表是响应客户端的请求，这也是我们在现在流程要关注的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processResponseCommand</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand cmd)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">opaque</span> <span class="operator">=</span> cmd.getOpaque();</span><br><span class="line">    <span class="comment">//根据唯一请求ID，获取到请求table中待处理的future对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ResponseFuture</span> <span class="variable">responseFuture</span> <span class="operator">=</span> responseTable.get(opaque);</span><br><span class="line">    <span class="keyword">if</span> (responseFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置返回报文</span></span><br><span class="line">        responseFuture.setResponseCommand(cmd);</span><br><span class="line">        responseTable.remove(opaque);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是异步请求，执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (responseFuture.getInvokeCallback() != <span class="literal">null</span>) &#123;</span><br><span class="line">            executeInvokeCallback(responseFuture);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他清空，释放CountDownLatch、释放信号量</span></span><br><span class="line">            responseFuture.putResponse(cmd);</span><br><span class="line">            responseFuture.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;receive response, but not matched any request, &quot;</span> + RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">        log.warn(cmd.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>producer</code>的发送流程结束，没有特别多逻辑，主要是组装报文，通过Netty请求到服务端，还有一些并发与锁控制流量与响应等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Producer发送消息源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
    <category term="MQ" scheme="https://www.wushiyi.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-Broker启动流程源码分析</title>
    <link href="https://www.wushiyi.top/2022/04/23/%E5%88%86%E5%B8%83%E5%BC%8F/Broker%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.wushiyi.top/2022/04/23/%E5%88%86%E5%B8%83%E5%BC%8F/Broker%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2022-04-23T15:15:12.000Z</published>
    <updated>2022-04-23T15:20:55.122Z</updated>
    
    <content type="html"><![CDATA[<p>Broker启动流程源码分析</p><span id="more"></span><p><code>Broker</code>的启动流程，和<code>Namesrv</code>类似，也是分<code>Contoller</code>的<strong>创建</strong>和<strong>启动</strong>。</p><blockquote><p>代码较多，会适当删除或者修改无需特意关注的代码（例如解析command之类的）</p></blockquote><h3 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title function_">createBrokerController</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//broker基本配置，主要为namesrv地址、brokerId、brokerName等</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BrokerConfig</span> <span class="variable">brokerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同namesrv，存放netty的默认配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">    <span class="comment">//Netty客户端配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">NettyClientConfig</span> <span class="variable">nettyClientConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否使用TLS</span></span><br><span class="line">    nettyClientConfig.setUseTLS(Boolean.parseBoolean(System.getProperty(TLS_ENABLE,</span><br><span class="line">        String.valueOf(TlsSystemConfig.tlsMode == TlsMode.ENFORCING))));</span><br><span class="line">    nettyServerConfig.setListenPort(<span class="number">10911</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放消息的配置，主要为存放地址、mmap配置、flush间隔时间等</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageStoreConfig</span> <span class="variable">messageStoreConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageStoreConfig</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Slave节点，消息占用内存比率为30%</span></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ratio</span> <span class="operator">=</span> messageStoreConfig.getAccessMessageInMemoryMaxRatio() - <span class="number">10</span>;</span><br><span class="line">        messageStoreConfig.setAccessMessageInMemoryMaxRatio(ratio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果开启Dleger同步功能，则每个brokerId都为-1</span></span><br><span class="line">    <span class="keyword">if</span> (messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">        brokerConfig.setBrokerId(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造BrokerController，里面有大量Manager、Config等代码，用到在看</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BrokerController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerController</span>(</span><br><span class="line">        brokerConfig, nettyServerConfig, nettyClientConfig, messageStoreConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化controller，主要为初始化Netty、设置Dleger、初始化各个线程池等</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">initResult</span> <span class="operator">=</span> controller.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化消息存储服务、Netty、消息处理线程池、RPC钩子等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化各个manager</span></span><br><span class="line">    <span class="comment">//topicConfigManager : 主要为保存各个topic的信息，当前的配置文件版本等.文件位置:&#123;user.home&#125;/store/config/topics.json</span></span><br><span class="line">    <span class="comment">//consumerOffsetManager : 消费进度管理类，可以查询或提交某个topic的消费进度. 文件位置:&#123;user.home&#125;/store/config/consumerOffset.json</span></span><br><span class="line">    <span class="comment">//subscriptionGroupManager : 订阅关系管理类。文件位置:&#123;user.home&#125;/store/config/subscriptionGroup.json</span></span><br><span class="line">    <span class="comment">//consumerFilterManager : 消费者过滤信息管理类  topic分组。文件位置：&#123;user.home&#125;/store/config/consumerFilter.json</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.topicConfigManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.consumerOffsetManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构造默认消息存储服务</span></span><br><span class="line">            <span class="built_in">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DefaultMessageStore</span>(<span class="built_in">this</span>.messageStoreConfig, <span class="built_in">this</span>.brokerStatsManager, <span class="built_in">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="built_in">this</span>.brokerConfig);</span><br><span class="line">            <span class="comment">//如果开启DLeger一致性功能，会默认创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">                <span class="type">DLedgerRoleChangeHandler</span> <span class="variable">roleChangeHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLedgerRoleChangeHandler</span>(<span class="built_in">this</span>, (DefaultMessageStore) messageStore);</span><br><span class="line">                ((DLedgerCommitLog)((DefaultMessageStore) messageStore).getCommitLog()).getdLedgerServer().getdLedgerLeaderElector().addRoleChangeHandler(roleChangeHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Broker统计工具类</span></span><br><span class="line">            <span class="built_in">this</span>.brokerStats = <span class="keyword">new</span> <span class="title class_">BrokerStats</span>((DefaultMessageStore) <span class="built_in">this</span>.messageStore);</span><br><span class="line">            <span class="comment">//加载消息存储插件</span></span><br><span class="line">            <span class="type">MessageStorePluginContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageStorePluginContext</span>(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">            <span class="built_in">this</span>.messageStore = MessageStoreFactory.build(context, <span class="built_in">this</span>.messageStore);</span><br><span class="line">            <span class="built_in">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherCalcBitMap</span>(<span class="built_in">this</span>.brokerConfig, <span class="built_in">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            log.error(<span class="string">&quot;Failed to initialize&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化消息存储服务，创建store路径的文件对于的mmap引用</span></span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">//创建netty服务器</span></span><br><span class="line">        <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="type">NettyServerConfig</span> <span class="variable">fastConfig</span> <span class="operator">=</span> (NettyServerConfig) <span class="built_in">this</span>.nettyServerConfig.clone();</span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.fastRemotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(fastConfig, <span class="built_in">this</span>.clientHousekeepingService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 各个apiCode对应的处理器线程池，比如发送消息、回复消息、查询消息、心跳服务等</span></span><br><span class="line">        <span class="comment">// ... 省略一堆线程池创建代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册对应apiCode对应等处理器</span></span><br><span class="line">        <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> UtilAll.computeNextMorningTimeMillis() - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">period</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">        <span class="comment">//启动定时统计服务</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="built_in">this</span>.getBrokerStats().record();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;schedule record error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动定义保存消费进度服务 文件位置:&#123;user.home&#125;/store/config/consumerOffset.json</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="built_in">this</span>.consumerOffsetManager.persist();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;schedule persist consumerOffset error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="built_in">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动过滤消息服务 文件位置:&#123;user.home&#125;/store/config/consumerFilter.json</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="built_in">this</span>.consumerFilterManager.persist();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;schedule persist consumer filter error.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SPI方式初始化事务消息服务</span></span><br><span class="line">        initialTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SPI方式加载验证服务</span></span><br><span class="line">        initialAcl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//SPI方式初始化RPC 接口调用钩子</span></span><br><span class="line">        initialRpcHooks();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a>启动Broker</h3><p>要启动的服务很多，每个服务的功能集成度也特别高，下面截取一些相对重要的做分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息存储服务启动</span></span><br><span class="line">    <span class="built_in">this</span>.messageStore.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Netty服务启动</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TLS使用的文件观察服务</span></span><br><span class="line">    <span class="built_in">this</span>.fileWatchService.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//broker对外API 启动</span></span><br><span class="line">    <span class="built_in">this</span>.brokerOuterAPI.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长轮询服务启动</span></span><br><span class="line">    <span class="built_in">this</span>.pullRequestHoldService.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//心跳连接处理服务</span></span><br><span class="line">    <span class="built_in">this</span>.clientHousekeepingService.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果未开启DLeger</span></span><br><span class="line">    <span class="keyword">if</span> (!messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">        <span class="comment">//如果是master节点，则启动事务消息检查服务</span></span><br><span class="line">        startProcessorByHa(messageStoreConfig.getBrokerRole());</span><br><span class="line">        <span class="comment">//同步slave服务启动，调用的是SlaveSynchronize.syncAll()</span></span><br><span class="line">        handleSlaveSynchronize(messageStoreConfig.getBrokerRole());</span><br><span class="line">        <span class="comment">//注册broker节点到namesrv上</span></span><br><span class="line">        <span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动定时注册broker到namesrv服务</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;registerBrokerAll Exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//broker状态管理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.brokerStatsManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.brokerStatsManager.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时清理过期请求服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.brokerFastFailure != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.brokerFastFailure.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Broker启动流程源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
    <category term="MQ" scheme="https://www.wushiyi.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ-Namesrv源码分析</title>
    <link href="https://www.wushiyi.top/2022/04/20/%E5%88%86%E5%B8%83%E5%BC%8F/Namesrv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://www.wushiyi.top/2022/04/20/%E5%88%86%E5%B8%83%E5%BC%8F/Namesrv%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-04-20T10:00:43.000Z</published>
    <updated>2022-04-23T15:14:57.294Z</updated>
    
    <content type="html"><![CDATA[<p>Namesrv源码分析</p><span id="more"></span><h3 id="Namesrv-启动流程"><a href="#Namesrv-启动流程" class="headerlink" title="Namesrv 启动流程"></a>Namesrv 启动流程</h3><p>首先先从Namesrv的启动开始，这是RocketMQ中类似注册中心的存在，代码也相对简单，集群部署时节点之间无通信调用，一般只和Broker、Producer、Consumer交互，对应的启动入口为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        main0(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">main0</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> createNamesrvController(args);</span><br><span class="line">        start(controller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>NamesrvStartup.main()</code>方法启动，首先会调用创建Namesrv的主实例NamesrvController，这个类主要作用为保存Namesrv的配置、Netty配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//创建namesrv配置、netty配置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">        nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//... 省略部分为处理从命令行读取配置等</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>NamesrvController</code>为Namesrv的主要类，里面存放大量功能服务类，这是其中一部分信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NamesrvController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//namesrv全局配置，主要为一些path路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamesrvConfig namesrvConfig;</span><br><span class="line">    <span class="comment">//Netty 服务器配置，主要为端口、selector线程数、worker线程数等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NettyServerConfig nettyServerConfig;</span><br><span class="line">    <span class="comment">//单线程定时任务线程池，主要为探活Broker、定时打印KV持久化配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(</span><br><span class="line">        <span class="string">&quot;NSScheduledThread&quot;</span>));</span><br><span class="line">    <span class="comment">//KV存储服务，内部存放一个table，类型为`HashMap&lt;String/* Namespace */, HashMap&lt;String/* Key */, String/* Value */&gt;&gt; configTable;` 使用`ReentrantReadWriteLock`读写锁和`map`实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KVConfigManager kvConfigManager;</span><br><span class="line">    <span class="comment">//路由信息服务，主要存放topic、broker、存活服务信息等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteInfoManager routeInfoManager;</span><br><span class="line">    <span class="comment">//Netty服务</span></span><br><span class="line">    <span class="keyword">private</span> RemotingServer remotingServer;</span><br><span class="line">    <span class="comment">//监听Broker与Namesrv的连接，如果有关闭、异常、空闲，主动把broker从存活table中移除</span></span><br><span class="line">    <span class="keyword">private</span> BrokerHousekeepingService brokerHousekeepingService;</span><br><span class="line">    <span class="comment">//Netty的worker线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService remotingExecutor;</span><br><span class="line">    <span class="comment">//namesrv的主要配置信息</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="comment">//文件监视器，主要用于观察SSL文件修改，会同步修改netty的tls信息。</span></span><br><span class="line">    <span class="keyword">private</span> FileWatchService fileWatchService;</span><br></pre></td></tr></table></figure><p>启动NamesrvController,这一阶段主要分为初始化(<code>initialize()</code>)与启动(<code>start()</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//载入kv配置</span></span><br><span class="line">        <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化Netty服务器（主要为配置Epoll/NIO，BOSS线程、Selector线程）</span></span><br><span class="line">        <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化Worker线程池</span></span><br><span class="line">        <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册默认Netty消息处理器，这个是namesrv默认处理请求的地方</span></span><br><span class="line">        <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个扫描线程池，扫描超过2分钟无心跳的channel并关闭</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 定时打印KV配置、处理SSL相关</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行Broker的start方法，主要是启动Netty服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">org.apache.rocketmq.remoting.netty.NettyRemotingServer</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//work线程池</span></span><br><span class="line">    <span class="built_in">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(nettyServerConfig.getServerWorkerThreads());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">childHandler</span> <span class="operator">=</span></span><br><span class="line">      <span class="comment">//boss、selector组合</span></span><br><span class="line">        <span class="built_in">this</span>.serverBootstrap.group(<span class="built_in">this</span>.eventLoopGroupBoss, <span class="built_in">this</span>.eventLoopGroupSelector) </span><br><span class="line">            .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class) <span class="comment">//使用epoll或nio</span></span><br><span class="line">            .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)<span class="comment">// backlog的定义是已连接但未进行accept处理的socket队列大小， 如果这个队列满了，将会发送一个ECONNREFUSED错误信息给到客户端，即“Connection refused”。</span></span><br><span class="line">            .option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)<span class="comment">// 一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</span></span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="literal">false</span>)<span class="comment">// 不使用TCP默认的keeplive心跳机制，详情见下方引用</span></span><br><span class="line">            .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)<span class="comment">// 不使用Nagle算法，直接发送</span></span><br><span class="line">            .childOption(ChannelOption.SO_SNDBUF, nettyServerConfig.getServerSocketSndBufSize())<span class="comment">//发送缓冲区大小</span></span><br><span class="line">            .childOption(ChannelOption.SO_RCVBUF, nettyServerConfig.getServerSocketRcvBufSize())<span class="comment">//接收缓冲区大小</span></span><br><span class="line">            .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.nettyServerConfig.getListenPort()))</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline()</span><br><span class="line">                        .addLast(defaultEventExecutorGroup, HANDSHAKE_HANDLER_NAME, handshakeHandler)<span class="comment">// </span></span><br><span class="line">                        .addLast(defaultEventExecutorGroup,</span><br><span class="line">                            encoder,<span class="comment">//编码</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">NettyDecoder</span>(),<span class="comment">//解码</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">0</span>, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),<span class="comment">//空闲管理器</span></span><br><span class="line">                            connectionManageHandler,</span><br><span class="line">                            serverHandler <span class="comment">// 这个为Netty的业务消息处理器，代码太多，主要为调用NamesrvController初始化阶段时，注册的消息处理器(DefaultRequestProcessor)</span></span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//... 启动Netty等代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时扫描请求响应表，处理里面已超时的请求</span></span><br><span class="line">    <span class="built_in">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NettyRemotingServer.<span class="built_in">this</span>.scanResponseTable();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;scanResponseTable exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提一下，为什么不使用TCP的keepLive？可以参考这篇 <a href="https://www.zhihu.com/question/40602902">https://www.zhihu.com/question/40602902</a></p></blockquote><p><code>DefaultRequestProcessor</code>处理Broker接收到的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">        RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RequestCode.PUT_KV_CONFIG:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.putKVConfig(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.GET_KV_CONFIG:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getKVConfig(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.DELETE_KV_CONFIG:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.deleteKVConfig(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.QUERY_DATA_VERSION:</span><br><span class="line">                <span class="keyword">return</span> queryBrokerTopicConfig(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.REGISTER_BROKER: <span class="comment">//注册Broker节点</span></span><br><span class="line">                <span class="type">Version</span> <span class="variable">brokerVersion</span> <span class="operator">=</span> MQVersion.value2Version(request.getVersion());</span><br><span class="line">                <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.registerBroker(ctx, request);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> RequestCode.UNREGISTER_BROKER: <span class="comment">//移除broker节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.unregisterBroker(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.GET_ROUTEINFO_BY_TOPIC: <span class="comment">// 通过topic获取路由信息（topic分部在哪些broker，以及queneID）</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class="line">            <span class="keyword">case</span> RequestCode.GET_BROKER_CLUSTER_INFO:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.getBrokerClusterInfo(ctx, request);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// ... 接口很多，我在下方列了一个表格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下为Namesrv的TCP接口列表</p><table><thead><tr><th align="left">枚举</th><th align="right">CODE</th><th align="center">DESC</th></tr></thead><tbody><tr><td align="left">PUT_KV_CONFIG</td><td align="right">100</td><td align="center">设置持久化KV值</td></tr><tr><td align="left">GET_KV_CONFIG</td><td align="right">101</td><td align="center">获取KV值</td></tr><tr><td align="left">DELETE_KV_CONFIG</td><td align="right">102</td><td align="center">删除KV值</td></tr><tr><td align="left">QUERY_DATA_VERSION</td><td align="right">322</td><td align="center">Broker调用，对比本地与namesrv的数据，判断namesrv是否已更新</td></tr><tr><td align="left">REGISTER_BROKER</td><td align="right">103</td><td align="center"><code>注册Broker</code></td></tr><tr><td align="left">UNREGISTER_BROKER</td><td align="right">104</td><td align="center"><code>注销broker</code></td></tr><tr><td align="left">GET_ROUTEINFO_BY_TOPIC</td><td align="right">105</td><td align="center">通过topic查询路由信息</td></tr><tr><td align="left">GET_BROKER_CLUSTER_INFO</td><td align="right">106</td><td align="center">获取Broker集群信息</td></tr><tr><td align="left">WIPE_WRITE_PERM_OF_BROKER</td><td align="right">205</td><td align="center">清理Broker</td></tr><tr><td align="left">GET_ALL_TOPIC_LIST_FROM_NAMESERVER</td><td align="right">206</td><td align="center">获取所有topic列表</td></tr><tr><td align="left">DELETE_TOPIC_IN_NAMESRV</td><td align="right">216</td><td align="center">删除topic</td></tr><tr><td align="left">GET_KVLIST_BY_NAMESPACE</td><td align="right">219</td><td align="center">通过namespace查询kv配置</td></tr><tr><td align="left">GET_TOPICS_BY_CLUSTER</td><td align="right">224</td><td align="center">通过集群名字查询topic</td></tr><tr><td align="left">GET_SYSTEM_TOPIC_LIST_FROM_NS</td><td align="right">304</td><td align="center">获取所有的clustername，所有的brokername，brokername的master brokerAddr</td></tr><tr><td align="left">GET_UNIT_TOPIC_LIST</td><td align="right">311</td><td align="center">获取topic的topicSynFlag属性是<code>FLAG_UNIT</code>的所有topicname</td></tr><tr><td align="left">GET_HAS_UNIT_SUB_TOPIC_LIST</td><td align="right">312</td><td align="center">获取topic的topicSynFlag属性是<code>FLAG_UNIT_SUB</code>的所有topicname</td></tr><tr><td align="left">UPDATE_NAMESRV_CONFIG</td><td align="right">318</td><td align="center">更新configuration这个类维护的property, nameServer中，这个类维护的是namesrvConfig，nettyServerConfig这两份配置</td></tr><tr><td align="left">GET_NAMESRV_CONFIG</td><td align="right">319</td><td align="center">查询configuration这个类维护的property</td></tr></tbody></table><h3 id="Namesrv的主要交互代码分析"><a href="#Namesrv的主要交互代码分析" class="headerlink" title="Namesrv的主要交互代码分析"></a>Namesrv的主要交互代码分析</h3><h4 id="Broker注册至Namesrv"><a href="#Broker注册至Namesrv" class="headerlink" title="Broker注册至Namesrv"></a>Broker注册至Namesrv</h4><p>broker的如何启动、运行不在本篇描述，可以查看另一篇<code>Broker源码分析</code>，总之在Broker启动后，会解析配置文件中的<code>NamesrvAddr</code>,发送103(<code>REGISTER_BROKER</code>), 104(<code>UNREGISTER_BROKER</code>)来注册或注销<code>Namesrv</code>.</p><h5 id="REGISTER-BROKER注册Broker"><a href="#REGISTER-BROKER注册Broker" class="headerlink" title="REGISTER_BROKER注册Broker"></a><code>REGISTER_BROKER</code>注册Broker</h5><p>入口为<code>registerBrokerWithFilterServer</code>, 其实这个filterServer不用太过关心，很少用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">registerBrokerWithFilterServer</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br><span class="line">        <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">        <span class="comment">//包装请求、返回值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RegisterBrokerResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span> (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RegisterBrokerRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span></span><br><span class="line">            (RegisterBrokerRequestHeader) request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验broker传过来的body是否完整</span></span><br><span class="line">        <span class="keyword">if</span> (!checksum(ctx, request, requestHeader)) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">&quot;crc32 not match&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析body</span></span><br><span class="line">        <span class="type">RegisterBrokerBody</span> <span class="variable">registerBrokerBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterBrokerBody</span>();</span><br><span class="line">        <span class="keyword">if</span> (request.getBody() != <span class="literal">null</span>) &#123;</span><br><span class="line">            registerBrokerBody = RegisterBrokerBody.decode(request.getBody(), requestHeader.isCompressed());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerBrokerBody.getTopicConfigSerializeWrapper().getDataVersion().setCounter(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>));</span><br><span class="line">            registerBrokerBody.getTopicConfigSerializeWrapper().getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册Broker节点，详情看后面</span></span><br><span class="line">        <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">            requestHeader.getClusterName(),</span><br><span class="line">            requestHeader.getBrokerAddr(),</span><br><span class="line">            requestHeader.getBrokerName(),</span><br><span class="line">            requestHeader.getBrokerId(),</span><br><span class="line">            requestHeader.getHaServerAddr(),</span><br><span class="line">            registerBrokerBody.getTopicConfigSerializeWrapper(),</span><br><span class="line">            registerBrokerBody.getFilterServerList(),</span><br><span class="line">            ctx.channel());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回namesrv节点信息</span></span><br><span class="line">        responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">        responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line">        <span class="type">byte</span>[] jsonValue = <span class="built_in">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG);</span><br><span class="line">        response.setBody(jsonValue);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>详细注册节点实现，主要为更新<code>RouteInfoManager</code>的几个节点Map、更新节点信息等，有关filterServer都移除了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RegisterBrokerResult <span class="title function_">registerBroker</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String clusterName,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String brokerAddr,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> <span class="type">long</span> brokerId,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> String haServerAddr,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span><br><span class="line"><span class="params">            <span class="keyword">final</span> Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterBrokerResult</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//RouteInfoManager全局使用的读写锁</span></span><br><span class="line">                <span class="built_in">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据集群名获取对于的broker名集合，并加入到集合</span></span><br><span class="line">                Set&lt;String&gt; brokerNames = <span class="built_in">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">                brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//是否首次注册</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">registerFirst</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据BrokerName获取Broker信息（Broker主节点、Slave节点等）</span></span><br><span class="line">                <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == brokerData) &#123;</span><br><span class="line">                    registerFirst = <span class="literal">true</span>;</span><br><span class="line">                    brokerData = <span class="keyword">new</span> <span class="title class_">BrokerData</span>(clusterName, brokerName, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, String&gt;());</span><br><span class="line">                    <span class="built_in">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">                <span class="comment">//Map&lt;BrokerId, BrokerAddr&gt;， 如果broker的地址一样，但是brokerId不一样，则直接从map中移除这个节点，后续做处理</span></span><br><span class="line">                Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;remove entry &#123;&#125; from brokerData&quot;</span>, item);</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//直接覆盖brokerId对应的地址</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">oldAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line"></span><br><span class="line">                registerFirst = registerFirst || (<span class="literal">null</span> == oldAddr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果为主节点，且broker携带的Topic的配置有变更过，则更新broker的topic配置信息</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != topicConfigWrapper</span><br><span class="line">                        &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                            || registerFirst) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (topicConfigWrapper.getTopicConfigTable() != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : topicConfigWrapper.getTopicConfigTable().entrySet()) &#123;</span><br><span class="line">                                <span class="built_in">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新节点存活时间戳</span></span><br><span class="line">                <span class="type">BrokerLiveInfo</span> <span class="variable">prevBrokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">BrokerLiveInfo</span>(</span><br><span class="line">                                System.currentTimeMillis(),</span><br><span class="line">                                topicConfigWrapper.getDataVersion(),</span><br><span class="line">                                channel,</span><br><span class="line">                                haServerAddr));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">masterAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                    <span class="keyword">if</span> (masterAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">BrokerLiveInfo</span> <span class="variable">brokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                        <span class="comment">//更新本地存的master节点地址</span></span><br><span class="line">                        <span class="keyword">if</span> (brokerLiveInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                            result.setMasterAddr(masterAddr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;registerBroker Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="UNREGISTER-BROKER-注销Broker"><a href="#UNREGISTER-BROKER-注销Broker" class="headerlink" title="UNREGISTER_BROKER 注销Broker"></a><code>UNREGISTER_BROKER</code> 注销Broker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterBroker</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String clusterName,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String brokerAddr,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> brokerId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//全局读写锁</span></span><br><span class="line">                <span class="built_in">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">                <span class="type">BrokerLiveInfo</span> <span class="variable">brokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.remove(brokerAddr);</span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">removeBrokerName</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != brokerData) &#123;</span><br><span class="line">                    <span class="comment">//直接从brokerAddrTable中移除broker信息</span></span><br><span class="line">                    brokerData.getBrokerAddrs().remove(brokerId);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//若移除了当前节点后，所有相同brokerName下的broker都不存在了，则认为从namesrv中移除了该brokerName</span></span><br><span class="line">                    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.brokerAddrTable.remove(brokerName);</span><br><span class="line">                        log.info(<span class="string">&quot;unregisterBroker, remove name from brokerAddrTable OK, &#123;&#125;&quot;</span>, brokerName);</span><br><span class="line"></span><br><span class="line">                        removeBrokerName = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 从clusterAddrTable中移除brokerName</span></span><br><span class="line">                <span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">                    Set&lt;String&gt; nameSet = <span class="built_in">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">                    <span class="keyword">if</span> (nameSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> nameSet.remove(brokerName);</span><br><span class="line">                        log.info(<span class="string">&quot;unregisterBroker, remove name from clusterAddrTable &#123;&#125;, &#123;&#125;&quot;</span>, removed ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;Failed&quot;</span>, brokerName);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (nameSet.isEmpty()) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.clusterAddrTable.remove(clusterName);</span><br><span class="line">                            log.info(<span class="string">&quot;unregisterBroker, remove cluster from clusterAddrTable &#123;&#125;&quot;</span>, );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//移除topic对应的相同brokerName的queue信息</span></span><br><span class="line">                    <span class="built_in">this</span>.removeTopicByBrokerName(brokerName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;unregisterBroker Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="GET-ROUTEINFO-BY-TOPIC-通过topic查询分布信息"><a href="#GET-ROUTEINFO-BY-TOPIC-通过topic查询分布信息" class="headerlink" title="GET_ROUTEINFO_BY_TOPIC 通过topic查询分布信息"></a><code>GET_ROUTEINFO_BY_TOPIC</code> 通过topic查询分布信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TopicRouteData <span class="title function_">pickupTopicRouteData</span><span class="params">(<span class="keyword">final</span> String topic)</span> &#123;</span><br><span class="line">        <span class="type">TopicRouteData</span> <span class="variable">topicRouteData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicRouteData</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">foundQueueData</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">foundBrokerData</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Set&lt;String&gt; brokerNameSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        List&lt;BrokerData&gt; brokerDataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BrokerData&gt;();</span><br><span class="line">        topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 查找topic对应的queue信息</span></span><br><span class="line">                <span class="comment">//            |  brokerName  |  readQueueNums  |  writeQueueNums  |  perm  |  topicSynFlag |</span></span><br><span class="line">                <span class="comment">// topic =&gt;   |  broker-a    |  8              |  8               |  6     |  0            |</span></span><br><span class="line">                <span class="comment">//            |  broker-b    |  8              |  8               |  6     |  0            |</span></span><br><span class="line">                <span class="comment">//            |  broker-c    |  8              |  8               |  6     |  0            |</span></span><br><span class="line">                List&lt;QueueData&gt; queueDataList = <span class="built_in">this</span>.topicQueueTable.get(topic);</span><br><span class="line">                <span class="keyword">if</span> (queueDataList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                    foundQueueData = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="type">QueueData</span> <span class="variable">qd</span> <span class="operator">=</span> it.next();</span><br><span class="line">                        brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//每个BrokerName对应一个BrokerData，BrokerData中包含该BrokerName对应的所有brokerId和brokerAddr</span></span><br><span class="line">                    <span class="keyword">for</span> (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                        <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> != brokerData) &#123;</span><br><span class="line">                            <span class="type">BrokerData</span> <span class="variable">brokerDataClone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerData</span>(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData.getBrokerAddrs().clone());</span><br><span class="line">                            brokerDataList.add(brokerDataClone);</span><br><span class="line">                            foundBrokerData = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;pickupTopicRouteData Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">            <span class="keyword">return</span> topicRouteData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要用clone? 看目的为了避免莫名其妙的引用修改，不过直接new一个是不是也没有什么性能损耗呢？</p></blockquote><p>其他的接口大同小异，无非都是根据cluster/topic/broker之类的信息查询，没有很多写操作</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Namesrv源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
    <category term="MQ" scheme="https://www.wushiyi.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>从0开始实现一个简易MVC框架</title>
    <link href="https://www.wushiyi.top/2022/02/09/Framework/mvc/easy-MVC/"/>
    <id>https://www.wushiyi.top/2022/02/09/Framework/mvc/easy-MVC/</id>
    <published>2022-02-09T04:10:00.000Z</published>
    <updated>2022-03-26T11:38:26.761Z</updated>
    
    <content type="html"><![CDATA[<p>从0开始实现一个简易MVC框架</p><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>框架基于<code>Servlet</code>实现，所有的请求都需要走代码中指定的<code>Servlet</code>，由一个<code>Servlet</code>做初始化与分发请求</li><li>内嵌<code>Tomcat</code></li><li>需要一些反射的知识</li><li>下方的代码只是把相对重要的部分展示，有很多工具类或者不太重要的地方请在Git查看（<a href="https://github.com/Wushiyii/MyMVC%EF%BC%89">https://github.com/Wushiyii/MyMVC）</a></li></ol><h2 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h2><h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><p>先导包，内嵌的<code>Tomcat</code>实际上已经把需要的<code>Servlet</code>相关的包导入了（主要的包就是<code>Tomcat</code>，其他都是些<code>Guava</code>、<code>Lombok</code>之类的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现请求入口"><a href="#实现请求入口" class="headerlink" title="实现请求入口"></a>实现请求入口</h3><blockquote><p>继承<code>HttpServlet</code>即可拦截所有的请求（Tomcat部分代码会进行mapping配置）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMVCServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本包路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> MyMVCConfiguration.getBasePackage();</span><br><span class="line">        log.info(<span class="string">&quot;MyMVC init basePackage:&quot;</span> + basePackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描注解</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; allPackageClass = ClassUtil.getPackageClass(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : allPackageClass) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Method declaredMethod : clazz.getDeclaredMethods()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(GET.class) || declaredMethod.isAnnotationPresent(POST.class)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//注册执行器端点</span></span><br><span class="line">                    EndpointManager.register(clazz, declaredMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行请求（所有的请求都会走这边）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        RequestHandlerTemplate.handle(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EndPoint执行器注册（主要就是拿一个<code>Table</code>存路由信息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndpointManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Table&lt;String, String, EndpointMetaInfo&gt; endpointTable = HashBasedTable.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不用考虑并发场景，只有启动时for循环注册一次</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt; clazz, Method declaredMethod)</span> &#123;</span><br><span class="line">        String[] multiPath = &#123;&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(GET.class)) &#123;</span><br><span class="line">            multiPath = declaredMethod.getAnnotation(GET.class).value();</span><br><span class="line">            method = Constants.GET;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredMethod.isAnnotationPresent(POST.class)) &#123;</span><br><span class="line">            multiPath = declaredMethod.getAnnotation(POST.class).value();</span><br><span class="line">            method = Constants.POST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">endPointObject</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="keyword">for</span> (String path : multiPath) &#123;</span><br><span class="line">            path = StringUtils.trimSlash(path);</span><br><span class="line">            <span class="type">EndpointMetaInfo</span> <span class="variable">metaInfo</span> <span class="operator">=</span> EndpointMetaInfo.builder()</span><br><span class="line">                    .path(path)</span><br><span class="line">                    .endpointObject(endPointObject)</span><br><span class="line">                    .method(declaredMethod)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">//只是把信息放到Guava提供的Table里面</span></span><br><span class="line">            register0(method, path, metaInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内嵌Tomcat实现"><a href="#内嵌Tomcat实现" class="headerlink" title="内嵌Tomcat实现"></a>内嵌<code>Tomcat</code>实现</h3><blockquote><p>只需要端口号、<code>contextPath</code>即可，其他信息都可选。比较关键的是要指定<code>Servlet</code>的<code>Mapping</code>范围，比如下方的<code>/*</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEmbedServer</span> <span class="keyword">implements</span> <span class="title class_">EmbedServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tomcat tomcat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEmbedServer</span><span class="params">(<span class="type">int</span> port, String contextPath)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.tomcat = <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">            <span class="built_in">this</span>.tomcat.setPort(port);</span><br><span class="line"></span><br><span class="line">            <span class="type">File</span> <span class="variable">root</span> <span class="operator">=</span> getRootFolder();</span><br><span class="line">            <span class="type">File</span> <span class="variable">webContentFolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(root.getAbsolutePath(), <span class="string">&quot;src/main/resources/&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!webContentFolder.exists()) &#123;</span><br><span class="line">                webContentFolder = Files.createTempDirectory(<span class="string">&quot;default-doc-base&quot;</span>).toFile();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) <span class="built_in">this</span>.tomcat.addWebapp(contextPath, webContentFolder.getAbsolutePath());</span><br><span class="line">            standardContext.setParentClassLoader(<span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="type">WebResourceRoot</span> <span class="variable">webResourceRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardRoot</span>(standardContext);</span><br><span class="line">            standardContext.setResources(webResourceRoot);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.tomcat.addServlet(contextPath, <span class="string">&quot;myMVCServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyMVCServlet</span>()).setLoadOnStartup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这边过滤了所有的请求，全部走这个servlet分发</span></span><br><span class="line">            standardContext.addServletMappingDecoded(<span class="string">&quot;/*&quot;</span>, <span class="string">&quot;myMVCServlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[MyMVC] Init Tomcat Server failed &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tomcat.start();</span><br><span class="line">        log.info(<span class="string">&quot;[MyMVC] start success, address: http://&#123;&#125;:&#123;&#125;&quot;</span>, <span class="built_in">this</span>.tomcat.getServer().getAddress(), <span class="built_in">this</span>.tomcat.getServer().getPort());</span><br><span class="line">        <span class="built_in">this</span>.tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="制作启动器"><a href="#制作启动器" class="headerlink" title="制作启动器"></a>制作启动器</h3><blockquote><p>很简单的<code>Builder</code>模式，可以扩展为读取配置文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMVCBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyMVCBuilder <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyMVCBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyMVCBuilder <span class="title function_">port</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        MyMVCConfiguration.setPort(port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyMVCBuilder <span class="title function_">contextPath</span><span class="params">(String contextPath)</span> &#123;</span><br><span class="line">        MyMVCConfiguration.setContextPath(contextPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Class&lt;?&gt; startClass)</span> &#123;</span><br><span class="line">        MyMVCConfiguration.setStartClass(startClass);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyEmbedServer</span>(MyMVCConfiguration.getPort(), MyMVCConfiguration.getContextPath()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求流程模板代码"><a href="#请求流程模板代码" class="headerlink" title="请求流程模板代码"></a>请求流程模板代码</h3><p>上方实现<code>MyMVCServlet</code>里面有重写<code>service</code>方法逻辑，<code>RequestHandlerTemplate.handle(req, resp)</code>这个就是处理请求的入口。实现也比较简单：</p><ul><li>构造上下文</li><li>不同请求method的参数处理</li><li>反射调用执行器处理逻辑</li><li>渲染结果</li></ul><blockquote><p>这些步骤其实都可以用<code>SPI</code>扩展，有兴趣可以加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestHandlerTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取处理器</span></span><br><span class="line">            <span class="type">RequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> RequestHandlerFactory.getHandler(req.getMethod());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//建立上下文</span></span><br><span class="line">            <span class="type">RequestContext</span> <span class="variable">context</span> <span class="operator">=</span> RequestContext.builder().req(req).resp(resp).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//预处理</span></span><br><span class="line">            handler.prepareContext(context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析参数</span></span><br><span class="line">            context.setParamMap(handler.parseParam(context));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            context.setOriginResult(handler.handleRequest(context));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理结果</span></span><br><span class="line">            handler.handleResponse(context);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;invoke method error, method=&#123;&#125;&quot;</span>, req.getMethod(), e);</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析入参"><a href="#解析入参" class="headerlink" title="解析入参"></a>解析入参</h3><p>不同请求方式的解析处理，如<code>POST</code>请求的入参就有多种处理方式：</p><ul><li><code>application/x-www-form-urlencoded</code>这种的请求会把参数放在parameterMap，解析同<code>GET</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">handleParameterMap</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    request.getParameterMap().forEach((paramName, paramsValues) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(paramsValues)) &#123;</span><br><span class="line">            paramMap.put(paramName, paramsValues[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> paramMap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>multipart/form-data</code>文件类型需要找一个临时文件夹放置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">handleMultiPart</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletRequestContext</span> <span class="variable">servletRequestContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestContext</span>(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">uploadPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;./&quot;</span>) + File.separator + UPLOAD_DIRECTORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FileItem&gt; formItems = uploader.parseRequest(servletRequestContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (formItems != <span class="literal">null</span> &amp;&amp; formItems.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (FileItem item : formItems) &#123;</span><br><span class="line">                <span class="comment">// 文件类型处理</span></span><br><span class="line">                <span class="keyword">if</span> (!item.isFormField()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(item.getName()).getName();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> uploadPath + File.separator + fileName;</span><br><span class="line">                    <span class="type">File</span> <span class="variable">storeFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">                    paramMap.put(item.getFieldName(), storeFile);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    paramMap.put(item.getFieldName(), item.getString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;upload file error &quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramMap;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>application/json</code>JSON类型直接从Body获取，按照流方式读取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">handleJSON</span><span class="params">(HttpServletRequest req)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 单行解析</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(req.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line">    String line;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将json字符串转换为json对象</span></span><br><span class="line">    <span class="keyword">return</span> JSONObject.parseObject(sb.toString(), MSS_TYPE_REFERENCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行器调用"><a href="#执行器调用" class="headerlink" title="执行器调用"></a>执行器调用</h3><p>执行器调用，入口为上方模板代码里的<code>handler.handleRequest(context)</code>。</p><blockquote><p>下方的<code>getReflectParameters</code>方法实现的是将<code>Map&lt;String, Object&gt;</code>这样的解析参数转化为需要反射调用的入参。至于为什么要用注解获取入参，这是由于JVM编译后，原入参名字无法保留，要开启的话也可以，会有性能损失</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeEndpoint</span><span class="params">(EndpointMetaInfo endpoint, Map&lt;String, Object&gt; paramMap)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过反射组装endpoint需要的入参</span></span><br><span class="line">    List&lt;Object&gt; parameters = getReflectParameters(endpoint, paramMap);</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="comment">//反射调用</span></span><br><span class="line">    <span class="keyword">if</span> (parameters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = endpoint.getMethod().invoke(endpoint.getEndpointObject(), parameters.toArray());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = endpoint.getMethod().invoke(endpoint.getEndpointObject());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">getReflectParameters</span><span class="params">(EndpointMetaInfo endpoint, Map&lt;String, Object&gt; requestMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endpoint.getMethod().getParameters().length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parameter[] parameters = endpoint.getMethod().getParameters();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = endpoint.getMethod().getParameterTypes();</span><br><span class="line">    List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    checkRequestType(endpoint.getMethod());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这边主要实现GET、POST的不同参数赋值逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">        <span class="type">Parameter</span> <span class="variable">param</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">        Class&lt;?&gt; type = parameterTypes[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过标记注解反射赋值回入参</span></span><br><span class="line">        <span class="type">PARAM</span> <span class="variable">pinedParam</span> <span class="operator">=</span> param.getAnnotation(PARAM.class);</span><br><span class="line">        <span class="type">BODY</span> <span class="variable">pinedBody</span> <span class="operator">=</span> param.getAnnotation(BODY.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(pinedParam) &amp;&amp; requestMap.containsKey(pinedParam.value())) &#123;</span><br><span class="line">            objectList.add(ClassUtil.generateParameterObject(type, requestMap.get(pinedParam.value())));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.nonNull(pinedBody)) &#123;</span><br><span class="line">            objectList.add(ClassUtil.generateBodyObject(type, requestMap));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            objectList.add(ClassUtil.generateDefaultObject(type));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objectList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>完成大体的框架，可以实现GET、POST的请求解析了，启动方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        MyMVCBuilder.of().start(App.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这仅仅是一个很简单的<code>Web</code>框架，功能还很不完善，不过大体的<code>MVC</code>处理流程都实现了，可以帮助读者理解实现<code>MVC</code>的几个核心点</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><p>Filter</p></li><li><p>REST</p></li><li><p>Cookie </p></li><li><p>Session</p></li><li><p>CSRF</p></li><li><p>Configuration</p></li></ul><p>地址：<a href="https://github.com/Wushiyii/MyMVC">https://github.com/Wushiyii/MyMVC</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从0开始实现一个简易MVC框架&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://www.wushiyi.top/categories/java/"/>
    
    
    <category term="MVC" scheme="https://www.wushiyi.top/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Netty（二）</title>
    <link href="https://www.wushiyi.top/2021/05/08/netty/netty(2)%20/"/>
    <id>https://www.wushiyi.top/2021/05/08/netty/netty(2)%20/</id>
    <published>2021-05-08T10:53:07.000Z</published>
    <updated>2022-03-26T11:38:26.771Z</updated>
    
    <content type="html"><![CDATA[<p>Netty组件的概念</p><span id="more"></span><h1 id="Netty（二）"><a href="#Netty（二）" class="headerlink" title="Netty（二）"></a>Netty（二）</h1><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p><code>ChannelHander</code>充当了所有处理入站和出战的逻辑处理容器，比如<code>ChannelInboundHandler</code>是一个处理接收入站信息的容器，<code>ChannelOutboundHandler</code>是处理出战信息的容器。一般而言，程序处理的业务逻辑通常会在多个<code>ChannelInboundHandler</code>。</p><h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><code>ChannelPipeline</code>即是一个链式处理各个<code>ChannelHandler</code>的流水管道。入站和出站的<code>ChannelHandler</code></p><p>可以被加到同一个<code>ChannelPipeline</code>中，当一个消息的入站事件被读取，<code>ChannelPipeline</code>既会开始各个handler的流动，最终达到<code>ChannePipeline</code>的尾端，届时，所有的处理就都结束了。</p><p>出站流程和入站几乎无差别，不过数据的流动是从<code>ChannelPipeline</code>的尾端开始流动，直到到达头部为止。</p><blockquote><p>入站与出战的<code>ChannelHandler</code>的类型是不同的，所以即使把这些处理器都加入到同一个pipeline，Netty也能区分开的，确保数据只会在相同类型的<code>ChannelHandler</code>之间流转。</p></blockquote><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><p>当使用Netty接收与发送一个消息时，就会发生一次数据转换。接收到入站消息，需要从字节类型转换成特定的报文格式（一般是Java对象）；接收到出战消息，则需要将当前的格式转换成字节类型。</p><p>这两种类型的转换，对应的抽象类为：入站(<code>ByteToMessageDecoder</code>)，出站(<code>MessageToByteEncoder</code>)。</p><h4 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h4><p><code>SimpleChannelInboundHandler</code>可以处理对应泛型<I>的消息，要注如果在pipeline链上，前一个<code>ChannelHandler</code>传过来的消息，必须和<I>指定的类型一致，否则不会解析消息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty组件的概念&lt;/p&gt;</summary>
    
    
    
    <category term="NETTY" scheme="https://www.wushiyi.top/categories/NETTY/"/>
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/tags/JAVA/"/>
    
    <category term="NETTY" scheme="https://www.wushiyi.top/tags/NETTY/"/>
    
  </entry>
  
  <entry>
    <title>Netty（一）</title>
    <link href="https://www.wushiyi.top/2021/05/08/netty/netty(1)/"/>
    <id>https://www.wushiyi.top/2021/05/08/netty/netty(1)/</id>
    <published>2021-05-08T08:02:07.000Z</published>
    <updated>2022-03-26T11:38:26.770Z</updated>
    
    <content type="html"><![CDATA[<p>Netty基础概念与实现一个Echo服务</p><span id="more"></span><h1 id="Netty（一）"><a href="#Netty（一）" class="headerlink" title="Netty（一）"></a>Netty（一）</h1><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>Channel -&gt; Socket； 一个Channel在它的生命周期内只注册在一个EventLoop上</li><li>EventLoop -&gt; 控制流、多线程处理、并发；一个EventLoop在它的生命周期内只和一个Thread绑定，一个EventLoop可能会绑定多个Channel。</li><li>ChannelFutre -&gt; 异步通知</li><li>EventLoopGroup -&gt;处理连接的生命周期，包含一个或多个EventLoop</li><li>ChannelFuture -&gt; Netty中所有操作都是异步的，通过ChannelFuture的addListener方法注册channelFutureListenner，可以在操作完成时进行获得通知。</li><li>ChannelHandler -&gt; 处理入站、出战数据的应用程序逻辑的容器。</li><li>ChannelPipeline -&gt; 提供ChannelHandler链的容器，ChannelHandler会被安装到pipeline中。</li></ul><h3 id="实现一个Echo服务"><a href="#实现一个Echo服务" class="headerlink" title="实现一个Echo服务"></a>实现一个Echo服务</h3><blockquote><p>客户端将消息发给服务端，服务端把同消息发给客户端</p></blockquote><p><code>EchoServer</code>负责服务端的启动、绑定等，<code>EchoServerHandler</code>负责真正的业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">//指定使用NIO传输channel</span></span><br><span class="line">                    .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port)) <span class="comment">//使用本地地址</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());<span class="comment">//echoServerHandler被标记了@Sharable 对于所有的客户端，都会使用同一个EchoServerHandler</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind().sync(); <span class="comment">//加上.sync() 的future都会阻塞获取，直到完成</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync(); <span class="comment">//阻塞获取当前bootstrap的channel，直到获取到对应的closeFuture</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync(); <span class="comment">//关闭eventLoopGroup</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EchoServer</span>(<span class="number">7070</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">in</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        log.info(<span class="string">&quot;收到消息: &#123;&#125;&quot;</span>, in.toString(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.write(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">                .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EchoClient</code>负责客户端的启动，<code>EchoClientHandler</code>负责服务端的业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoClient</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">eventLoopGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(eventLoopGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//NIO传输，客户端类型</span></span><br><span class="line">                    .remoteAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port))</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect().sync();<span class="comment">// 连接远程节点，阻塞到完成</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync(); <span class="comment">//阻塞获取closeFuture 直至关闭channel</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully().sync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EchoClient</span>(<span class="number">7070</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Hello~&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;客户端收到消息: &#123;&#125;&quot;</span>, msg.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty基础概念与实现一个Echo服务&lt;/p&gt;</summary>
    
    
    
    <category term="NETTY" scheme="https://www.wushiyi.top/categories/NETTY/"/>
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/tags/JAVA/"/>
    
    <category term="NETTY" scheme="https://www.wushiyi.top/tags/NETTY/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务的导出与引入</title>
    <link href="https://www.wushiyi.top/2020/08/28/Framework/dubbo/%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5/"/>
    <id>https://www.wushiyi.top/2020/08/28/Framework/dubbo/%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5/</id>
    <published>2020-08-28T08:40:11.000Z</published>
    <updated>2022-03-26T11:38:26.761Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo的服务是怎么创建的？消费端又是怎么引入服务呢？</p><span id="more"></span><p>Dubbo 服务导出过程始于 Spring 容器发布刷新事件(<code>Refresh</code>)，Dubbo 在接收到事件后，会立即执行服务导出逻辑。</p><p>整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。</p><h3 id="导出Dubbo服务"><a href="#导出Dubbo服务" class="headerlink" title="导出Dubbo服务"></a>导出Dubbo服务</h3><ol><li><h5 id="参数校验及URL装配"><a href="#参数校验及URL装配" class="headerlink" title="参数校验及URL装配"></a>参数校验及URL装配</h5></li></ol><p>在Spring容器的各个启动阶段，Spring会进行当前阶段事件的广播。在Spring进行容器刷新的事件，dubbo通过接受事件开始Dubbo的启动。具体的方法入口，可以见ServiceBean.onApplicationEvent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());</span><br><span class="line">           &#125;</span><br><span class="line">           export();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参数检查这一步骤主要进行的是：</p><ul><li>检测服务interfaceName是否为空</li><li>检测provider是否为空，为空则创建</li><li>检测服务是否为泛化类型，若不是则对服务的interfaceClass、methd进行校验</li><li>检测application、registry、protocal等对象是否为空，不为空则创建或者报错</li></ul><ol start="2"><li><h5 id="导出服务"><a href="#导出服务" class="headerlink" title="导出服务"></a>导出服务</h5></li></ol><ul><li>加载注册中心连接，并组装pid、path、时间戳、protocal参数等</li><li>根据注册中心连接、protcal、host、port以及额外的parameter等参数组装好URL</li><li>导出Dubbo服务<ul><li>根据URL中的scope判断导出到本地或远程</li><li>创建Invoker（由ProxyFactory创建，默认使用Javaassist创建）；创建过程主要是通过javaassist生成对应类的各个set、get、构造函数、字段、方法代码等</li><li>导出服务<ul><li>创建DubboExporter</li><li>启动服务器（默认使用netty，也可以使用mina）</li></ul></li><li>获取注册中心地址串、根据URL加载到对应注册中心的实现类Registry</li><li>向服务提供者注册表与消费者注册表周注册服务提供者</li><li>向注册中心注册服务、创建服务监听器、向注册中心进行订阅 override 数据</li></ul></li></ul><ol start="3"><li><h5 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h5></li></ol><ul><li><p>通过URL获取对应的注册中心实现类（默认为zookeeper）</p></li><li><p>通过<em>CuratorZookeeperTransporter</em>创建Zookeeper客户端；添加zookeeper状态监听器</p></li><li><p>在zookeeper中创建服务节点，节点路径如：*/dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1……</p></li></ul><p>至此，服务导出完成，主要包括<code>配置检测</code>，<code>URL 组装</code>，<code>Invoker 创建</code>、<code>导出服务</code>以及<code>注册服务</code>等等</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo的服务是怎么创建的？消费端又是怎么引入服务呢？&lt;/p&gt;</summary>
    
    
    
    <category term="framework" scheme="https://www.wushiyi.top/categories/framework/"/>
    
    
    <category term="distribute、framework、dubbo" scheme="https://www.wushiyi.top/tags/distribute%E3%80%81framework%E3%80%81dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Mysql执行计划的Extra信息</title>
    <link href="https://www.wushiyi.top/2020/08/25/SQL/%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/"/>
    <id>https://www.wushiyi.top/2020/08/25/SQL/%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/</id>
    <published>2020-08-25T02:55:03.000Z</published>
    <updated>2022-03-26T11:38:26.769Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql执行计划的Extra信息</p><span id="more"></span><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `oms_goods_item_inventory` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `warehouse_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;仓库库存id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品sku编码&#x27;</span>,</span><br><span class="line">  `goods_item_no` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;货号&#x27;</span>,</span><br><span class="line">  `current_qty` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;现货库存&#x27;</span>,</span><br><span class="line">  `lock_qty` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;锁定库存&#x27;</span>,</span><br><span class="line">  `dispatch_qty` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;调拨占用库存&#x27;</span>,</span><br><span class="line">  `version` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,</span><br><span class="line">  `create_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_at` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uniq_warehouse_sku_goods_item_no` (`warehouse_id`,`sku_id`,`goods_item_no`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1188</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT<span class="operator">=</span><span class="string">&#x27;库存表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>插入10条测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `oms_goods_item_inventory` (`id`, `warehouse_id`, `sku_id`, `goods_item_no`, `barcode`, `current_qty`, `lock_qty`, `dispatch_qty`, `damage_qty`, `invalid_current_qty`, `invalid_current_dispatch_qty`, `version`, `create_at`, `update_at`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1186&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;559&#x27;</span>, <span class="string">&#x27;158763472600001&#x27;</span>, <span class="string">&#x27;2966_36_38NO NER1&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2020-07-30 10:39:24&#x27;</span>, <span class="string">&#x27;2020-08-10 16:38:09&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1185&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;459&#x27;</span>, <span class="string">&#x27;158763472600001&#x27;</span>, <span class="string">&#x27;2966_36_38NO NERO&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2020-07-30 10:38:55&#x27;</span>, <span class="string">&#x27;2020-08-05 15:44:12&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1184&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;559&#x27;</span>, <span class="string">&#x27;158763472600001&#x27;</span>, <span class="string">&#x27;2966_36_38NO NER1&#x27;</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;2020-07-27 20:25:44&#x27;</span>, <span class="string">&#x27;2020-08-05 15:43:55&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1183&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;11477&#x27;</span>, <span class="string">&#x27;158894384600001&#x27;</span>, <span class="string">&#x27;1641701645235&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;2020-05-11 15:54:05&#x27;</span>, <span class="string">&#x27;2020-08-10 16:59:47&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1182&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;70385&#x27;</span>, <span class="string">&#x27;4979006070064&#x27;</span>, <span class="string">&#x27;4979006070064&#x27;</span>, <span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;2020-06-05 11:40:39&#x27;</span>, <span class="string">&#x27;2020-07-30 15:32:21&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1181&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;70385&#x27;</span>, <span class="string">&#x27;158885889700001&#x27;</span>, <span class="string">&#x27;4979006070064&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;2020-05-08 11:23:43&#x27;</span>, <span class="string">&#x27;2020-08-20 10:49:27&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1180&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;70818&#x27;</span>, <span class="string">&#x27;3473311421005&#x27;</span>, <span class="string">&#x27;3473311421005&#x27;</span>, <span class="string">&#x27;81&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;62&#x27;</span>, <span class="string">&#x27;2020-05-13 21:56:28&#x27;</span>, <span class="string">&#x27;2020-07-15 14:27:00&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1179&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;70820&#x27;</span>, <span class="string">&#x27;3473311320001&#x27;</span>, <span class="string">&#x27;3473311320001&#x27;</span>, <span class="string">&#x27;142&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;2020-05-13 21:56:28&#x27;</span>, <span class="string">&#x27;2020-07-20 15:25:43&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1178&#x27;</span>, <span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;380&#x27;</span>, <span class="string">&#x27;158876899800001&#x27;</span>, <span class="string">&#x27;26R47613811R_38&#x27;</span>, <span class="string">&#x27;96&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;2020-05-26 22:02:17&#x27;</span>, <span class="string">&#x27;2020-06-17 15:49:28&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1177&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;250&#x27;</span>, <span class="string">&#x27;TSKU15&#x27;</span>, <span class="string">&#x27;PW2S0F01RVH0JT_35&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;2020-05-25 09:59:45&#x27;</span>, <span class="string">&#x27;2020-06-29 08:14:17&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><ul><li>Using index</li></ul><p>查询的列被索引覆盖，where条件命中的是符合最左匹配原则的索引</p><p><strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> warehouse_id <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> warehouse_id <span class="operator">=</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>ref</td><td>uniq_warehouse_sku_goods_item_no</td><td>uniq_warehouse_sku_goods_item_no</td><td>8</td><td>const</td><td>4</td><td>100.00</td><td>Using index</td></tr></tbody></table><ul><li>Using where; Using index</li></ul><ol><li>查询的列被索引覆盖，但是where条件命中的不是最左匹配原则的索引，而是联合索引其中之一，意味着无法直接通过索引查询到符合条件的数据</li></ol><p><strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> warehouse_id <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> sku_id <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>index</td><td>uniq_warehouse_sku_goods_item_no</td><td>uniq_warehouse_sku_goods_item_no</td><td>532</td><td></td><td>157</td><td>10.00</td><td>Using where; Using index</td></tr></tbody></table><ol start="2"><li>查询的列被索引覆盖，并且where条件是符合最左匹配原则索引的一个范围，同样意味着无法直接通过索引查询到符合条件的数据</li></ol><p><strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> warehouse_id <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> warehouse_id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> warehouse_id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>range</td><td>uniq_warehouse_sku_goods_item_no</td><td>uniq_warehouse_sku_goods_item_no</td><td>8</td><td></td><td>155</td><td>100.00</td><td>Using where; Using index</td></tr></tbody></table><ul><li>Using where</li></ul><p>查询的列<strong>未被</strong>索引覆盖，并且where条件未命中索引，或命中的是联合索引中非最左匹配原则的索引</p><p><strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> current_qty <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> sku_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">explain <span class="keyword">select</span> current_qty <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> current_qty <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>ALL</td><td></td><td></td><td></td><td></td><td>157</td><td>10.00</td><td>Using where</td></tr></tbody></table><ul><li>Using index condition</li></ul><p>查询的列<strong>未完全被</strong>索引覆盖，并且where条件是符合最左匹配原则索引的范围查询</p><p><strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> warehouse_id <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> warehouse_id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>range</td><td>uniq_warehouse_sku_goods_item_no</td><td>uniq_warehouse_sku_goods_item_no</td><td>8</td><td></td><td>21</td><td>100.00</td><td>Using index</td></tr></tbody></table><ul><li>NULL</li></ul><p>查询的列<strong>未被</strong>索引覆盖，并且where条件符合最左匹配原则索引。这意味着用到了索引，但是部分字段没被索引覆盖，需要回表查询，并不是纯粹用到索引。</p><p>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> oms_goods_item_inventory <span class="keyword">where</span> warehouse_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>oms_goods_item_inventory</td><td></td><td>ref</td><td>uniq_warehouse_sku_goods_item_no</td><td>uniq_warehouse_sku_goods_item_no</td><td>8</td><td>const</td><td>1</td><td>100.00</td><td></td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Extra 为 <code>Using index</code></li></ol><p>查询的列被索引覆盖 <strong>并且</strong> where条件符合最左匹配原则 ，此时<strong>无需回表</strong>查询。</p><ol start="2"><li>Extra 为<code>Using where;Using index</code></li></ol><p>出现<code>Using where Using index</code>意味着是通过索引扫描（或者表扫描）来实现sql语句执行的，即便是符合最左匹配原则的索引范围查找也有一点范围扫描的动作，不管是前非索引前导列引起的，还是非索引列查询引起的。</p><ol start="3"><li>Extra 为 NULL</li></ol><p>查询列存在未被索引覆盖 <strong>并且</strong> where条件符合最左匹配原则， 此时<strong>需要回表</strong>来找到未被索引覆盖的字段。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql执行计划的Extra信息&lt;/p&gt;</summary>
    
    
    
    <category term="SQL" scheme="https://www.wushiyi.top/categories/SQL/"/>
    
    
    <category term="SQL" scheme="https://www.wushiyi.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo SPI</title>
    <link href="https://www.wushiyi.top/2020/08/01/Framework/dubbo/Dubbo%20SPI/"/>
    <id>https://www.wushiyi.top/2020/08/01/Framework/dubbo/Dubbo%20SPI/</id>
    <published>2020-08-01T04:23:34.000Z</published>
    <updated>2022-03-26T11:38:26.761Z</updated>
    
    <content type="html"><![CDATA[<p>SPI全称为<code>Service Provider Interface</code>,即服务发现。类似于Spring的IOC一样，SPI注入的类可以被加载到runtime中。</p><span id="more"></span><p>SPI 的本质是将接口实现类的全限定名配置在文件中（文件名称即是接口的全限定名），并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p><h3 id="SPI简易用法与原理"><a href="#SPI简易用法与原理" class="headerlink" title="SPI简易用法与原理"></a>SPI简易用法与原理</h3><p>首先定义一个需要实现SPI的接口，比如这边定一个<code>Animal</code>接口作为规范。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再增加几个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Monkey.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am Snake.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resource</code>文件夹下建立<code>META-INF/services</code>文件夹（为什么是这个文件夹？原理部分有说明），放入接口全限定名为名称的文件，并在文件里写上实现类的全限定名，文件夹结构类似这样</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java</span></span><br><span class="line"><span class="attr">-com</span></span><br><span class="line"><span class="attr">-wushiyii</span></span><br><span class="line"><span class="attr">-messy</span></span><br><span class="line"><span class="attr">-grammer</span></span><br><span class="line"><span class="attr">-spi</span></span><br><span class="line"><span class="attr">-Animal.class</span></span><br><span class="line"><span class="attr">-Monkey.class</span></span><br><span class="line"><span class="attr">-Snake.class</span></span><br><span class="line"><span class="attr">resource</span></span><br><span class="line"><span class="attr">-</span> <span class="string">META-INF</span></span><br><span class="line"><span class="attr">-</span> <span class="string">services</span></span><br><span class="line"><span class="attr">com.wushiyii.messy.grammar.spi.Animal</span></span><br></pre></td></tr></table></figure><p>文件<code>com.wushiyii.messy.grammar.spi.Animal</code>里的内容是</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.wushiyii.messy.grammar.spi.Monkey</span></span><br><span class="line"><span class="attr">com.wushiyii.messy.grammar.spi.Snake</span></span><br></pre></td></tr></table></figure><p>另外在写一个SPI Test 来看结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Animal&gt; serviceLoader = ServiceLoader.load(Animal.class);</span><br><span class="line">        serviceLoader.forEach(Animal::sayHello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Out:</span></span><br><span class="line"><span class="comment">// Hello, I am Monkey.</span></span><br><span class="line"><span class="comment">// Hello, I am Snake.</span></span><br></pre></td></tr></table></figure><p><code>SPI</code>的原理是什么？在SPI test中，Animal类是通过ServiceLoader来进行加载发现，点开ServiceLoader看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要加载的interface</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载SPi的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现SPI的类实例</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程的懒加载迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceLoader已经固定写死了，只能从<code>&quot;META-INF/services&quot;</code>文件夹下读取SPI实现类。再来看一下整个SPI的运行加载原理，首先从<code>ServiceLoader.load(Animal.class)</code>开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">  <span class="comment">//获取当前线程的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">    <span class="comment">// service对象在此被赋值，即要实现的interface</span></span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断当前classLoader是否为空</span></span><br><span class="line">        loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">  <span class="comment">// 获取AccessController的当前上下文快照</span></span><br><span class="line">        acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//载入</span></span><br><span class="line">        reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reload方法的意图很简单，生成一个懒加载机制的迭代器，等到真正去用的时候才会去`META-INF/services`下寻找并实例化实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">        providers.clear();</span><br><span class="line">        lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用的时候，会进行实例化等操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 记录下一个实例类名</span></span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 组装路径名+全限定接口名</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">// 判断刚刚读取到的`Enumeration&lt;URL&gt; configs`是否存在下一个元素，是的话就解析</span></span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Iterator&lt;String&gt; <span class="title function_">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span></span><br><span class="line">        <span class="keyword">throws</span> ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 打开输入流</span></span><br><span class="line">            in = u.openStream();</span><br><span class="line">          <span class="comment">// 转为Reader读取</span></span><br><span class="line">            r = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 读取解析是通过`parseLine`来实现的，每次读取一行，并放置在names中</span></span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error reading configuration file&quot;</span>, x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>) r.close();</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>) in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException y) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error closing configuration file&quot;</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拿到服务是通过iterator的next方法进行读取的，而next方法会执行nextService方法，实例化就是在nextService中发生的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="comment">// hasNext中传递下来的nextName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">    nextName = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试加载读取到的类</span></span><br><span class="line">        c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化</span></span><br><span class="line">        <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">      <span class="comment">// 将实例化的类放到之前的linkedHashMap中</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，SPI的加载与实例化都完成了，所以在SPI test中，可以直接调用<code>sayHello()</code>方法。</p><p>通过SPI可以使第三方服务模块的逻辑与业务代码相分离，而不耦合在一起，应用程序可以根据实际业务进行扩展。但是SPI也存在缺点：</p><ul><li>做不到按需加载，如果要拿到自己的实现，最坏情况需要一直执行next，遍历完整个iterator才能找到需要的实现类</li><li>不能提供类似IOC的功能</li><li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持</li></ul><h3 id="Dubbo里的SPI"><a href="#Dubbo里的SPI" class="headerlink" title="Dubbo里的SPI"></a>Dubbo里的SPI</h3><p>Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制，Dubbo实现SPI的逻辑封装在ExtensionLoader类中，Dubbo SPi的文件放在<code>META-INF/dubbo</code>下，配置文件例如</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">monkey</span>=<span class="string">com.alibaba.dubbo.common.extensionloader.Monkey</span></span><br><span class="line"><span class="attr">snake</span>=<span class="string">com.alibaba.dubbo.common.extensionloader.Snake</span></span><br></pre></td></tr></table></figure><p>配置文件是以键值进行配置的，如下面的test案例，可以实现按需加载了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ExtensionLoader&lt;Animal&gt; extensionLoader =</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Animal.class);</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">monkey</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;monkey&quot;</span>);</span><br><span class="line">    monkey.sayHello();</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">snake</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;snake&quot;</span>);</span><br><span class="line">    snake.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dubbo-SPI-源码分析"><a href="#Dubbo-SPI-源码分析" class="headerlink" title="Dubbo SPI 源码分析"></a>Dubbo SPI 源码分析</h4><p>首先先看ExtensionLoader的对象参数，可以发现Dubbo读取的SPI扩展类是在META-INF/dubbo下读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ExtensionLoader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICES_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/dubbo/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_INTERNAL_DIRECTORY</span> <span class="operator">=</span> DUBBO_DIRECTORY + <span class="string">&quot;internal/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">NAME_SEPARATOR</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\s*[,]+\\s*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"> </span><br><span class="line"> /...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">  <span class="comment">// class type必须为接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type(&quot;</span> + type + <span class="string">&quot;) is not interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接口必须有@SPI注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type(&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not extension, because WITHOUT @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot; Annotation!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 从缓存中获取ExtensionLoader，如未获取到则创建一个</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtension是获取扩展类的核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">      <span class="comment">// 获取默认的拓展实现类</span></span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//Holder的作用是持有一个对象，内部存放一个volatile的value值</span></span><br><span class="line">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">        cachedInstances.putIfAbsent(name, <span class="keyword">new</span> <span class="title class_">Holder</span>&lt;Object&gt;());</span><br><span class="line">        holder = cachedInstances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">  <span class="comment">// 双检锁，为空则新建一个扩展，并放入holder中</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//新建扩展</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扩展类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">//加载所有扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="literal">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance(name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;)  could not be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension首先会调用getExtensionClasses来加载所有扩展类；loadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 加载扩展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SPI</span> <span class="variable">defaultAnnotation</span> <span class="operator">=</span> type.getAnnotation(SPI.class);</span><br><span class="line">  <span class="comment">// 从SPI注解里获取需要默认加载的key</span></span><br><span class="line">        <span class="keyword">if</span> (defaultAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> defaultAnnotation.value();</span><br><span class="line">            <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">                <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;more than 1 default extension name on extension &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + Arrays.toString(names));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="comment">//加载`META-INF/services/`、`META-INF/dubbo/`、`META-INF/dubbo/internal`下所有SPI实现类</span></span><br><span class="line">        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">        loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">        loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">        <span class="keyword">return</span> extensionClasses;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loadDirectory 方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">      <span class="comment">// 使用classloader获取资源URL</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">              <span class="comment">//根据资源URL解析class</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception when load extension class(interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadResource主要用于读取配置文件并解析，加载实现类，并通过loadClass进行校验与缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">          <span class="comment">// 读取一行</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// # 号分割，截取 # 之前的字符串，# 之后的内容为注释，需要忽略</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                      <span class="comment">// =号分割，截取key、value</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="comment">// 装载SPI实现类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="literal">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class(interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception when load extension class(interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">  <span class="comment">// 判断加载的类是否为接口的实现类</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Error when load extension class(interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot;is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断实现类时否含有@Adaptive注解</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 设置 cachedAdaptiveClass缓存</span></span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;More than 1 adaptive class found: &quot;</span></span><br><span class="line">                    + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                    + <span class="string">&quot;, &quot;</span> + clazz.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 判断加载类是否是Wrapper类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrappers == <span class="literal">null</span>) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">            wrappers = cachedWrapperClasses;</span><br><span class="line">        &#125;</span><br><span class="line">        wrappers.add(clazz);</span><br><span class="line">      <span class="comment">// 加载类为普通扩展类</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为name</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//切分配置</span></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (names != <span class="literal">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Activate</span> <span class="variable">activate</span> <span class="operator">=</span> clazz.getAnnotation(Activate.class);</span><br><span class="line">            <span class="keyword">if</span> (activate != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，</span></span><br><span class="line">          <span class="comment">// 存储 name 到 Activate 注解对象的映射关系</span></span><br><span class="line">                cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                  <span class="comment">// 存储 Class 到名称的映射关系</span></span><br><span class="line">                    cachedNames.put(clazz, n);</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 存储名称到 Class 的映射关系</span></span><br><span class="line">                    extensionClasses.put(n, clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Duplicate extension &quot;</span> + type.getName() + <span class="string">&quot; name &quot;</span> + n + <span class="string">&quot; on &quot;</span> + c.getName() + <span class="string">&quot; and &quot;</span> + clazz.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadCLass方法也不复杂，主要是设置cachedAdaptiveClass、cachedActivates、cachedNames（Class与名称映射关系） 这三个缓存，以上几步就完成了从META-INF中装载dubbo扩展类到runtime中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SPI全称为&lt;code&gt;Service Provider Interface&lt;/code&gt;,即服务发现。类似于Spring的IOC一样，SPI注入的类可以被加载到runtime中。&lt;/p&gt;</summary>
    
    
    
    <category term="framework" scheme="https://www.wushiyi.top/categories/framework/"/>
    
    
    <category term="distribute、framework、dubbo" scheme="https://www.wushiyi.top/tags/distribute%E3%80%81framework%E3%80%81dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Paxos and Raft</title>
    <link href="https://www.wushiyi.top/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8F/Paxos%20distribute%20consensnus/"/>
    <id>https://www.wushiyi.top/2020/07/19/%E5%88%86%E5%B8%83%E5%BC%8F/Paxos%20distribute%20consensnus/</id>
    <published>2020-07-19T13:10:00.000Z</published>
    <updated>2022-03-26T11:38:26.771Z</updated>
    
    <content type="html"><![CDATA[<p>Google Chubby的作者Mike Burrows说过， <code>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.</code> 意即<strong>世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</strong></p><span id="more"></span><blockquote><p> Paxos算法即是用于解决分布式系统中，如何就某个值（也可能是某个决议、某个指令）达成共识的算法。</p></blockquote><h3 id="拜占庭将军"><a href="#拜占庭将军" class="headerlink" title="拜占庭将军"></a>拜占庭将军</h3><p>拜占庭军队的将军们打算就是否进攻敌军进行决议，但是将军们又分散在不同的阵地，阵地之间距离遥远只能通过通讯兵来传达消息。但是通讯兵中存在叛徒，有着篡改消息的能力，通过消息就能欺骗将军是否进行行动。</p><p>Paxos算法的前提是不存在拜占庭将军问题，节点之间通信的信道是安全的，发出的信号不会被篡改，所以Paxos是<strong>基于消息传递</strong>的。</p><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p>在Paxos算法中，一共有三个角色</p><ul><li>Proposers：提议者</li><li>Acceptors：议员</li><li>Learners：学习者</li></ul><p>Proposers提出提案，Acceptor对提案作出决定（accept or not），Leaner负责学习提案结果。<strong>一个节点可能同时作为3个角色</strong>。Proposers 提出提案，提案信息包括提案编号和提议的 value；acceptor 收到提案后可以接受（accept）提案，若提案获得多数派（majority）的 acceptors 的接受，则称该提案被批准（chosen）；learners 只能“学习”被批准的提案</p><blockquote><ol><li>决议（value）只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案（proposal）”）；</li><li>在一次 Paxos 算法的执行实例中，只批准（chosen）一个 value；</li><li>learners 只能获得被批准（chosen）的 value。</li></ol></blockquote><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>Paxos算法类似于2PC，也是分为两个阶段</p><ul><li>第一阶段（prepare）</li></ul><ol><li>proposer选择一个提案编号M并将prepare请求发送给acceptors中的一个多数派；</li><li>acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；</li></ol><ul><li>第二阶段（accept）</li></ul><ol><li>当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，这个时候如果响应中过半是无任何提案信息的，则代表当前的提案的取值可以是任意值；如果响应中过半是其他的提案信息，那么则从中找到最大编号的提案编号V，组成【M、V】的请求发给acceptors</li><li>acceptor接收到请求，如果accpetor没有通过比V还大的编号，则会自动同意此提案。如果半数以上都同意，则通过当前提案。</li></ol><h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><p>Raft算法中同样也有三个角色</p><ul><li>Leader：处理所有客户端交互，日志复制等，一般一次只有一个Leader</li><li>Follower：类似选民，完全被动</li><li>Candidate：类似Proposer律师，可以被选为一个新的领导人 </li></ul><p><img src="https://miro.medium.com/max/580/1*TO9R_SS5Tfn07b0sObfhgg.png" alt="raft"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Google Chubby的作者Mike Burrows说过， &lt;code&gt;there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.&lt;/code&gt; 意即&lt;strong&gt;世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute、Algorithm" scheme="https://www.wushiyi.top/tags/distribute%E3%80%81Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2PC、3PC</title>
    <link href="https://www.wushiyi.top/2020/07/01/%E5%88%86%E5%B8%83%E5%BC%8F/2PC%E3%80%813PC/"/>
    <id>https://www.wushiyi.top/2020/07/01/%E5%88%86%E5%B8%83%E5%BC%8F/2PC%E3%80%813PC/</id>
    <published>2020-07-01T04:57:43.000Z</published>
    <updated>2022-03-26T11:38:26.771Z</updated>
    
    <content type="html"><![CDATA[<p>About distribute consistency</p><span id="more"></span><h3 id="分布式一致性的问题"><a href="#分布式一致性的问题" class="headerlink" title="分布式一致性的问题"></a>分布式一致性的问题</h3><p>在一个分布式系统中，存在多个节点，而在每个节点中的数据都有可能存在不一致的情况。比如Mysql主从复制的原理是启一个异步线程定时从master节点拉取数据，这就存在数据短暂不一致的情况。</p><p>为了解决分布式一致问题，比较著名的算法协议有<code>2PC</code>（Two Phase Commit Protocol）、<code>3PC</code>（Three Phase Commit Protocol）、<code>Paxos</code>、<code>Raft</code>等。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><blockquote><p><strong>分布式事务</strong>是指在多个数据库之间通过一些分布式协议，实现支持跨数据库的事务支持</p></blockquote><p>在分布式系统中，每个节点都是独立保持ACID的，节点与节点之间的数据并不能保持一致。如果需要保持一致性，那就需要在一次节点交互中进行事务的提交与回滚。但是每个节点只能控制自己的ACID，并不能知道对方的执行情况，这时候就需要一个事务协调者来统一调度各个节点的事务执行。</p><h3 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h3><p>X/Open组织提出的DTP分布式模型，包括了四个部分</p><ul><li>应用程序（AP）</li><li>事务管理器（TM）</li><li>资源管理器（RM）</li><li>通信资源管理器（CRM）</li></ul><p><strong>XA</strong>则是DTP模型中<strong>TM</strong>（事务管理器）与<strong>RM</strong>（资源管理器）通讯的接口规范。XA规范的目的是允许多个资源（如数据库，应用服务器，消息队列，等等）在同一事务中访问，这样可以使<a href="https://zh.wikipedia.org/wiki/ACID">ACID</a>属性跨越应用程序而保持有效</p><p>XA的接口由数据库厂商提供，TM根据XA的接口来通知数据库事务的开始、结束、提交与回滚等。2PC、3PC就是根据这个思想衍生出来的。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><blockquote><p> <strong>2PC</strong>即<strong>二阶段提交</strong>（Two-phase Commit）是指在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>以及<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>领域内，为了使基于<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">分布式系统</a>架构下的所有节点在进行<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">事务</a>提交时保持一致性而设计的一种<a href="https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95">算法</a>。</p></blockquote><h4 id="第一阶段（准备阶段）"><a href="#第一阶段（准备阶段）" class="headerlink" title="第一阶段（准备阶段）"></a>第一阶段（准备阶段）</h4><img src="https://www.debugger.wiki/sourceimg/190710/c3c5e917447a583d83da4451c75c6eaa.jpg" alt="2pc-1" style="zoom:50%;" /><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将<a href="https://zh.wikipedia.org/w/index.php?title=Undo%E4%BF%A1%E6%81%AF&action=edit&redlink=1">Undo信息</a>和<a href="https://zh.wikipedia.org/w/index.php?title=Redo%E4%BF%A1%E6%81%AF&action=edit&redlink=1">Redo信息</a>写入日志。</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol><h4 id="第二阶段（提交阶段）"><a href="#第二阶段（提交阶段）" class="headerlink" title="第二阶段（提交阶段）"></a>第二阶段（提交阶段）</h4><ul><li>参与者节点皆为成功</li></ul><img src="https://www.debugger.wiki/sourceimg/190710/e3ade8abfb29ee74e94b6112b7f096e1.jpg" alt="2pc-2" style="zoom:50%;" /><p>当协调者节点从所有参与者节点获得的响应消息都为”同意”时：</p><ol><li>协调者节点向所有参与者节点发出”正式提交”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol><ul><li>当参与者节点存在失败</li></ul><img src="https://www.debugger.wiki/sourceimg/190710/b67c41099678e7bda4a88a5cf82f777a.jpg" alt="2pc-3" style="zoom:50%;" /><p>如果任一参与者节点在第一阶段返回的响应消息为”终止”，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p><ol><li>协调者节点向所有参与者节点发出”回滚操作”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点收到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol><p>有时候，第二阶段也被称作<strong>完成阶段</strong>，因为无论结果怎样，协调者都必须在此阶段结束当前事务。</p><p>2PC看起来已经可以很好的解决分布式事务问题了，但是缺存在着几个缺点</p><blockquote><ul><li>同步阻塞：事务执行过程中，所有节点都是事务阻塞的状态；当事务占用的资源有其他节点需要获取，其他节点也需要阻塞等待资源释放。</li><li>单点故障：一旦协调者节点发生故障，参与者在事务开启时会一直阻塞，无法继续完成事务。</li><li>数据不一致：在第二阶段时，协调者向各个参与者发送正式提交（commit）请求，此时有可能发生网络异常或协调者自身宕机等异常，导致只有部分参与者接受到提交指令，其他节点无法执行事务提交，这便出现了数据不一致现象。</li></ul></blockquote><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><blockquote><p><strong>3PC</strong>即<strong>三阶段提交</strong>（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。<br>2、在第一阶段和第二阶段中插入一个<strong>准备阶段</strong>。保证了在最后提交阶段之前各参与节点的状态是一致的。</p></blockquote><p>与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，</p><p>3PC增加了超时机制，并且把2PC的准备阶段分为两部分。一共有了3个阶段<code>canCommit</code>、<code>preCommit</code>、doCommit`。</p><img src="https://www.debugger.wiki/sourceimg/190710/b3df48b48db1c589a78ce8980eaff41a.jpg" alt="3pc" style="zoom:50%;" /><ul><li>canCommit</li></ul><ol><li><strong>事务询问</strong>：<strong>协调者</strong>向<strong>参与者</strong>发送<code>canCommit</code>请求，询问是否可以执行事务</li><li><strong>响应反馈</strong>：<strong>参与者</strong>收到<code>canCommit</code>请求，根据实际情况返回，如果其自身认为可以顺利执行事务，则返回<code>Yes</code>，并进入预提交状态。否则反馈<code>No</code></li></ol><ul><li>preCommit</li></ul><p>如果<strong>协调者</strong>接受到所有<strong>参与者</strong>的反馈都为<code>Yes</code>，那就继续执行<code>preCommit</code></p><ol><li><strong>发送预提交请求</strong>：协调者向参与者发送<code>preCommit</code>，并进入<code>prepared</code>阶段</li><li><strong>事务预提交</strong>：参与者接受到<code>preCommit</code>请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</li><li><strong>响应反馈</strong>：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li></ol><p>如果协调者在接受参与者反馈时，有部分出现超时或返回<code>No</code>，协调者将会执行事务中断</p><ol><li><strong>发送事务中断请求</strong>：协调者向所有参与者发送<code>abort</code>请求</li><li><strong>中断事务</strong>：参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求，此为3PC新加的参与者超时），执行事务的中断。</li></ol><ul><li>doCommit</li></ul><p>此阶段进行真正的事务提交</p><ol><li><strong>发送提交事务</strong>：协调者接受到参与者发送到<code>ACK</code>响应，此时的事务状态将由预提交状态转为提交状态，并向所有参与者发送<code>doCommit</code>请求</li><li><strong>事务提交</strong>：参与者接受到<code>doCommit</code>请求后，执行正式的事务提交，在完成事务后释放所有事务资源。</li><li><strong>响应反馈</strong>：事务提交后，向协调者发送<code>ACK</code>响应</li><li><strong>完成事务</strong>：协调者收到所有参与者的<code>ACK</code>响应后，完成事务</li></ol><p>如果协调者最终在接受参与者反馈时，有部分出现超时或不是返回<code>ACK</code>，那么就将执行中断事务</p><ol><li><strong>发送中断请求</strong>：协调者向所有参与者发送<code>abort</code>请求</li><li><strong>事务回滚</strong>：参与者接受到<code>abort</code>请求后，根据在<code>preCommit</code>阶段记录的undo信息来执行事务回滚，并在回滚完成后释放事务资源。</li><li><strong>响应反馈</strong>：参与者完成事务回滚后，向协调者发送<code>ACK</code>响应</li><li><strong>中断事务</strong>：协调者接受到参与者的反馈的<code>AKC</code>后，执行事务中断</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;About distribute consistency&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性理论、CAP、BASE</title>
    <link href="https://www.wushiyi.top/2020/06/23/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%90%86%E8%AE%BA%E3%80%81CAP%E3%80%81BASE/"/>
    <id>https://www.wushiyi.top/2020/06/23/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%90%86%E8%AE%BA%E3%80%81CAP%E3%80%81BASE/</id>
    <published>2020-06-23T08:29:12.000Z</published>
    <updated>2022-03-26T11:38:26.771Z</updated>
    
    <content type="html"><![CDATA[<p>分布式一致性理论是由于分布式难以避免的节点故障产生的理论，以此来介绍下CAP与BASE理论</p><span id="more"></span><h3 id="分布式常见故障"><a href="#分布式常见故障" class="headerlink" title="分布式常见故障"></a>分布式常见故障</h3><ul><li>网络异常</li></ul><p>分布式系统需要在各个节点间通信，无论是http、rpc还是MQ，网络异常的情况无法避免。造成网络异常的原因有很多，比如节点宕机、网络超时等；</p><ul><li>网络分区（脑裂）</li></ul><p><img src="http://img.lessisbetter.site/2019-03-Network_Partition_for_Optimization-2.png" alt="splits network"></p><blockquote><p>图片来自WIKI</p></blockquote><p>WIKI对于网络分区给出的定义是：A <strong>network partition</strong> refers to network decomposition into relatively independent <a href="https://en.wikipedia.org/wiki/Subnetwork">subnets</a> for their separate optimization as well as network split due to the failure of network devices</p><p>节点与节点之间由于各种异常原因造成分区，最终造成整个分布式系统，只有部分节点有效，并且会产生多个小集群。</p><p><strong>分区原因</strong>：</p><ol><li>外部：网络交换设备故障等</li><li>内部：节点异常等</li></ol><ul><li>节点故障</li></ul><p>在分布式系统中，每个节点都有可能发生故障现象，原因也有很多：宕机、失去响应等</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p><img src="https://static.wixstatic.com/media/933668_c8bd69bd93a642db824b4ebaedd45b6f~mv2.png/v1/fill/w_406,h_350,al_c,usm_0.66_1.00_0.01/933668_c8bd69bd93a642db824b4ebaedd45b6f~mv2.png" alt="cap"></p><p>CAP即为：<code>Consistency</code>、<code>Availability</code>、<code>Partition-tolerance</code></p><ul><li><strong>一致性</strong>（<strong>C</strong>onsistency）：等同于所有节点访问同一份最新的数据副本(<code>all nodes see the same data at the same time</code>)</li><li><strong>可用性</strong>（<strong>A</strong>vailability）：每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据(<code>Reads and writes always succeed</code>)</li><li><strong>分区容错性</strong>（<strong>P</strong>artition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择(<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>)</li></ul><blockquote><p>CAP理论中的CA和数据库事务中ACID的CA并完全是同一回事儿。两者之中的A都是C都是一致性(Consistency)。CAP中的A指的是可用性（Availability），而ACID中的A指的是原子性（Atomicity)</p></blockquote><p>对于本地事务（相对分布式事务），只需要保证ACID模型即可。而在分布式系统中，针对一次业务的事务，如果要求最终数据的一致性，则很有可能需要放弃A（可用性）。</p><blockquote><p> CAP三者只能取其二，不能全都保证*</p></blockquote><h4 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h4><p>在这种情况下，分布式系统可以不要求强可用性，即允许系统暂时停机或无响应。这种情况下，就会牺牲用户体验，等待所有数据都一致后才能继续使用系统。</p><p>以CP为核心的系统最典型的为一些分布式数据库，比如<code>Redis</code>、<code>HBase</code>等，在发生异常时，优先保证数据一致性；还有常用的分布式组件<code>Zookeeper</code>也是CP的选择优先保证CP的。</p><h4 id="AP-without-C"><a href="#AP-without-C" class="headerlink" title="AP without C"></a>AP without C</h4><p>AP即为保证高可用，且允许分区，但是不保证数据一致性。为了保证高可用，用户请求节点的时候需要马上得到返回内容，则每个节点都只能使用本地数据，从而导致全局的数据不一致。</p><p>很多系统为了保证服务高可用，而选择放弃数据强一致性，这些系统只需保证最终一致性即可。比如12306、淘宝等系统，在买票的时候显示有票，下单的时候就报错了，这就是暂时的数据不一致。</p><h4 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h4><p>CA即为：只保证高可用与强一致性。而分布式系统天生就是需要分区的，所以CA在分布式中几乎不存在。</p><p>一些传统RDBMS数据库比如Mysql、Oracle在单机情况就保证了CA，但是在主从之类的集群部署时，也会存在CAP选择的问题。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><blockquote><p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，<a href="http://47.103.216.138/archives/666">CAP</a>的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p></blockquote><p>BASE并不是B、A、S、E，而是BA（Basic Available 基本可用）、S（Soft State 软状态）、E（Eventually Consistency 最终一致性）三个。</p><ul><li><strong>基本可用</strong>（Basic Available）：分布式系统出现故障时，允许损失部分可用性，但系统核心是可用的。比如电商系统的下单接口，在峰值请求时可能服务器压力太大，为了服务核心可用，部分用户会被引导到服务降级的页面，避免全部流量打入引起服务雪崩。</li><li><strong>软状态</strong>（Soft State）：指允许系统中的数据存在中间状态，并且该状态不会影响到系统的整体可用性，即允许分布式系统中各个节点的数据同步存在延时，比如Mysql的主从复制，在生产环境通常会延迟0.1～1s。</li><li><strong>最终一致性</strong>（Eventually Consistency）：分布式系统中所有节点在经过一段时间后，最终能达到数据的一致性</li></ul><blockquote><p><strong>最终一致性</strong>是一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够获取到最新的值。<strong>同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟、系统负载和数据复制方案设计等因素</strong>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式一致性理论是由于分布式难以避免的节点故障产生的理论，以此来介绍下CAP与BASE理论&lt;/p&gt;</summary>
    
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/categories/distribute/"/>
    
    
    <category term="distribute" scheme="https://www.wushiyi.top/tags/distribute/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动分析</title>
    <link href="https://www.wushiyi.top/2020/06/11/Java/Spring/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://www.wushiyi.top/2020/06/11/Java/Spring/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2020-06-11T02:12:02.000Z</published>
    <updated>2022-03-26T11:38:26.763Z</updated>
    
    <content type="html"><![CDATA[<p>Build a ApplicationContext, And run it</p><span id="more"></span><h3 id="1-构造SpringBoot实例"><a href="#1-构造SpringBoot实例" class="headerlink" title="1.构造SpringBoot实例"></a>1.构造SpringBoot实例</h3><p>一个<code>SpringBoot</code>的启动入口，往往是通过一个main函数+@SpringBootApplication启动，并且在这之上会有很多特性注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.xxx&quot;, &quot;com.xxx&quot;&#125;)</span></span><br><span class="line"><span class="meta">@MapperScan(value = &quot;com.xxx&quot;, sqlSessionTemplateRef = &quot;xxxSqlSessionTemplate&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;com.xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下，SpringApplication.run 会去创建一个新的SpringApplication实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span><br><span class="line"><span class="params">      String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的构造函数，主要做了检验当前的应用环境（REACTIVE、SERVLET、NONE，见deduceFromClasspath方法）、设置应用的初始化器、监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">   <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">  <span class="comment">// 判断当前的应用环境</span></span><br><span class="line">   <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  <span class="comment">// 设置应用初始化启动器，会扫描所有jar包的 META-INF/spring.factories 中找到ApplicationContextInitializer 并实例化初始化器</span></span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">         ApplicationContextInitializer.class));</span><br><span class="line">  <span class="comment">// 设置应用初始化监听器，会扫描所有jar包的 META-INF/spring.factories 中找到ApplicationListener 并实例化初始化器</span></span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  <span class="comment">// 根据当前Runtime对应的栈帧列表StackTraceElement，判断并设置启动springboot的main类</span></span><br><span class="line">   <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个Springboot的实例就构造完了，接下来是启动的部分</p><h3 id="2-启动"><a href="#2-启动" class="headerlink" title="2.启动"></a>2.启动</h3><p>先看一下启动源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">// 初始化一个计时器</span></span><br><span class="line">   <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">  <span class="comment">// 获取SpringApplicationRunListener（如有配置）</span></span><br><span class="line">   <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Springboot启动时，监听starting步骤</span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 构造启动Springboot的参数对象</span></span><br><span class="line">      <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(</span><br><span class="line">            args);</span><br><span class="line">     </span><br><span class="line">      <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">     <span class="comment">// 配置spring.beaninfo.ignore的值</span></span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">     <span class="comment">// 打印banner</span></span><br><span class="line">      <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">     <span class="comment">// 创建ApplicationContext容器</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">     <span class="comment">// 获取SpringBootExceptionReporter，收集上报exception用</span></span><br><span class="line">      exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">            SpringBootExceptionReporter.class,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">     <span class="comment">// 执行创建完ApplicationContext的回调方法、执行各个应用的初始化initialize()方法</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">     <span class="comment">// 刷新context容器(Beanfatroy刷新、BeanPostProcesser注册、JavaConfig解析等等..)</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">     <span class="comment">// 执行完refresh的hook</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      listeners.started(context);</span><br><span class="line">     <span class="comment">// 执行runner方法</span></span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners.running(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext的构造、加载与最终完成分为多个阶段</p><ul><li><p>SpringbootRunListener记录当前context执行到了starting阶段，并广播event到所有监听类</p></li><li><p>createApplicationContext（创建applicationContext）</p><ul><li><p>判断当前应用环境，SERVLET(SpringMVC)、REACTIVE（WebFlux）、NONE(默认的非web)，并实例化对应的applicationContext</p></li><li><p>```java<br>protected ConfigurableApplicationContext createApplicationContext() {<br>   Class&lt;?&gt; contextClass = this.applicationContextClass;<br>   if (contextClass == null) {</p><pre><code>  try &#123;    // 判断应用环境，创建对应的applicationContext对象     switch (this.webApplicationType) &#123;     case SERVLET:        contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);        break;     case REACTIVE:        contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);        break;     default:        contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);     &#125;  &#125;  catch (ClassNotFoundException ex) &#123;     throw new IllegalStateException(           &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;,ex);  &#125;</code></pre><p>   }<br>   return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prepaerContext（准备applicationContext）</span><br><span class="line"></span><br><span class="line">  - 执行创建完applicationContext的回调方法</span><br><span class="line"></span><br><span class="line">  - 执行各个应用的初始化器对应的initialize()方法（初始化器为META-INF/spring.factories中配置的ApplicationContextInitializer）</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      protected void applyInitializers(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        // 获取所有初始化器</span><br><span class="line">         for (ApplicationContextInitializer initializer : getInitializers()) &#123;</span><br><span class="line">            Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</span><br><span class="line">                  initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">            Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);</span><br><span class="line">           // 执行</span><br><span class="line">            initializer.initialize(context);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringbootRunListener记录当前context执行到了contextPrepared阶段，并广播event到所有监听类</p></li><li><p>打印startUp信息<code>2020/07/20 15:28:57.604  main [INFO] XxxApplication (StartupInfoLogger.java:50) Starting XxxApplication on bogon with PID 31681 (/Users/workspace/java/xxx//target/classes started by xxx in /Users/xxx/workspace/java/xxx)</code></p></li><li><p>加载启动主类（XxxAppcalition）</p><ul><li>创建BeanDefinitionLoader</li><li>加载XxxAppcalition</li></ul></li><li><p>SpringbootRunListener记录当前context执行到了contextLoaded阶段，并广播event到所有监听类</p></li></ul></li><li><p>refreshContext（刷新容器，方法很多）</p><ul><li><p>```java<br>public void refresh() throws BeansException, IllegalStateException {<br>   synchronized (this.startupShutdownMonitor) {</p><pre><code>  prepareRefresh();  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  prepareBeanFactory(beanFactory);  try &#123;     postProcessBeanFactory(beanFactory);     invokeBeanFactoryPostProcessors(beanFactory);     registerBeanPostProcessors(beanFactory);     initMessageSource();     initApplicationEventMulticaster();     onRefresh();     registerListeners();     finishBeanFactoryInitialization(beanFactory);     finishRefresh();  &#125;  catch (BeansException ex) &#123;     destroyBeans();     cancelRefresh(ex);     throw ex;  &#125;  finally &#123;     resetCommonCaches();  &#125;</code></pre><p>   }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- prepareRefresh（准备刷新）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    protected void prepareRefresh() &#123;</span><br><span class="line">       // 恢复到激活状态</span><br><span class="line">       this.startupDate = System.currentTimeMillis();</span><br><span class="line">       this.closed.set(false);</span><br><span class="line">       this.active.set(true);</span><br><span class="line">       // ...</span><br><span class="line">       // 初始化placeholder对应的值</span><br><span class="line">       initPropertySources();</span><br><span class="line">       //验证环境必须属性</span><br><span class="line">       getEnvironment().validateRequiredProperties();</span><br><span class="line">       // ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>obtainFreshBeanFactory（刷新beanFactory，步骤很简单，就是干掉所有单例bean、干掉beanFactory、重新创建beanFacotry、重新加载beanDefinitions）</p><ul><li>```java<br>protected final void refreshBeanFactory() throws BeansException {<br>  // 如果存在beanFactory，则干掉所有bean、关闭beanFactory<br>   if (hasBeanFactory()) {<pre><code>  destroyBeans();  closeBeanFactory();</code></pre>   }<br>   try {<pre><code> // 创建一个listableBeanFactory  DefaultListableBeanFactory beanFactory = createBeanFactory();  beanFactory.setSerializationId(getId());  customizeBeanFactory(beanFactory); // 加载beanDefinitions  loadBeanDefinitions(beanFactory);  synchronized (this.beanFactoryMonitor) &#123;     this.beanFactory = beanFactory;  &#125;</code></pre>   }<br>   catch (IOException ex) {<pre><code>  throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</code></pre>   }<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- prepareBeanFactory（拿到重新创建的beanFacotry，配置一些默认参数、接口、classlorder）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">       // 设置ClassLoarder、设置表达式解析器、添加属性编辑注册器</span><br><span class="line">       beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">       beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">       beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line">    </span><br><span class="line">       // 设置ApplicationContextAwareProcessor, 以下6个ignoreDependencyInterface的目的是因为ApplicationContextAwareProcessor已经把这6个的工作做了</span><br><span class="line">       beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line">       beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">    </span><br><span class="line">       // 设置几个特殊dependency类型bean</span><br><span class="line">       beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">       beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">       beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">       beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line">    </span><br><span class="line">       // Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">       beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line">    </span><br><span class="line">       // ...</span><br><span class="line">       // 设置一些默认变量</span><br><span class="line">       if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">          beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">       &#125;</span><br><span class="line">       if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">          beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">       &#125;</span><br><span class="line">       if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">          beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>postProcessBeanFactory（设置一些需要提前创建的BeanPostProcessors类）</p><ul><li><p>BeanPostProcessor的作用是在bean实例化前后都有对应的调用方法可以执行</p></li><li><p>–&gt;  Spring IOC容器实例化Bean<br> –&gt;  调用BeanPostProcessor的postProcessBeforeInitialization方法<br> –&gt;  调用bean实例的初始化方法<br> –&gt;  调用BeanPostProcessor的postProcessAfterInitialization方法</p></li><li><p>```java<br>@Override<br>protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {<br>  // 将WebApplicationContextServletContextAwareProcessor设置到postProcesser中<br>   beanFactory.addBeanPostProcessor(</p><pre><code>     new WebApplicationContextServletContextAwareProcessor(this));</code></pre><p>   beanFactory.ignoreDependencyInterface(ServletContextAware.class);<br>   registerWebApplicationScopes();<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- invokeBeanFactoryPostProcessors（实例化所有BeanPostProcessors类）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">      // 实例化所有BeanPostProcessors类</span><br><span class="line">       PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">    </span><br><span class="line">       // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class="line">       // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class="line">       if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">          beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">          beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>registerBeanPostProcessors</p></li><li><p>initMessageSource（初始化messageSource（国际化支持））</p></li><li><p>initApplicationEventMulticaster（初始化ApplicationEventMulticaster（事件广播器，用于通知事件到实现了ApplicationListener的类））</p><ul><li><p>```java<br>protected void initApplicationEventMulticaster() {<br>  // 从ConfigurableListableBeanFactory中判断是否有applicationEventMulticaster，有则赋值、无准创建并注册到BeanFactory<br>   ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>   if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {</p><pre><code>  this.applicationEventMulticaster =        beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</code></pre><p>   }<br>   else {</p><pre><code> // 创建  this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); // 注册单例对象  beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);</code></pre><p>   }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- onRefresh（执行其他特殊beans的模板方法）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Override</span><br><span class="line">    protected void onRefresh() &#123;</span><br><span class="line">       super.onRefresh();</span><br><span class="line">       try &#123;</span><br><span class="line">         // ServletWebServerApplicationContext实现的是创建一个webServer</span><br><span class="line">          createWebServer();</span><br><span class="line">       &#125;</span><br><span class="line">       catch (Throwable ex) &#123;</span><br><span class="line">          throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>private void createWebServer() {<br>   WebServer webServer = this.webServer;<br>   ServletContext servletContext = getServletContext();<br>   if (webServer == null &amp;&amp; servletContext == null) {</p><pre><code> // getWebServerFactory会从ServletWebServerFactory中取到当前环境的web容器bean（Tomcat、UnderTow、Jetty）  ServletWebServerFactory factory = getWebServerFactory();  this.webServer = factory.getWebServer(getSelfInitializer());</code></pre><p>   }<br>   else if (servletContext != null) {</p><pre><code>  try &#123;     getSelfInitializer().onStartup(servletContext);  &#125;  catch (ServletException ex) &#123;     throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,           ex);  &#125;</code></pre><p>   }<br>   initPropertySources();<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- registerListeners（初始化Springboot里的ApplicationListeners，并注册到ApplicationEventMulticaster里）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    protected void registerListeners() &#123;</span><br><span class="line">       // 注册所有ApplicationListeners到EventMulticaster中</span><br><span class="line">       for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">          getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">       &#125;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">      // 如果存在earlyApplicationEvents，则直接广播出去</span><br><span class="line">       Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">       this.earlyApplicationEvents = null;</span><br><span class="line">       if (earlyEventsToProcess != null) &#123;</span><br><span class="line">          for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">             getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>finishBeanFactoryInitialization（实例化BeanFactory中已经被注册但是未实例化的所有实例(Lazy init除外)）</p></li><li><p>finishRefresh（完成refresh，执行LifecycleProcessor的onRefresh回调）</p><ul><li>```java<br>protected void finishRefresh() {<br>   // 清除resource缓存<br>   clearResourceCaches();   // 初始化LifecycleProcessor<br>   initLifecycleProcessor();   // 执行onRefresh方法<br>   getLifecycleProcessor().onRefresh();   // 发布容器refresh完成的通知<br>   publishEvent(new ContextRefreshedEvent(this));   // Participate in LiveBeansView MBean, if active.<br>   LiveBeansView.registerApplicationContext(this);<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- resetCommonCaches（恢复一些Util的缓存）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    protected void resetCommonCaches() &#123;</span><br><span class="line">       ReflectionUtils.clearCache();</span><br><span class="line">       AnnotationUtils.clearCache();</span><br><span class="line">       ResolvableType.clearCache();</span><br><span class="line">       CachedIntrospectionResults.clearClassLoader(getClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>afterRefresh（预留方法，作为refresh后的hook调用）</p></li><li><p>SpringbootRunListener记录当前context执行到了started阶段，并广播event到所有监听类</p></li><li><p>callRunners</p><ul><li><p>获取所有实现ApplicationRunner、CommandLineRunner的类</p></li><li><p>根据@Ordered注解排序调用Runner的run方法</p></li><li><pre><code class="java">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;   List&lt;Object&gt; runners = new ArrayList&lt;&gt;();  // 从listableBeanFactory获取所有实现ApplicationRunner、CommandLineRunner的类   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());  // 根据Ordered注解排序   AnnotationAwareOrderComparator.sort(runners);   for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;      if (runner instanceof ApplicationRunner) &#123;         callRunner((ApplicationRunner) runner, args);      &#125;      if (runner instanceof CommandLineRunner) &#123;         callRunner((CommandLineRunner) runner, args);      &#125;   &#125;&#125;</code></pre></li></ul></li><li><p>SpringbootRunListener记录当前context执行到了running阶段，并广播event到所有监听类</p></li></ul><p>至此就完成了Springboot的启动，不过这只是主体的启动流程，还有一些细枝末节的地方没有分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Build a ApplicationContext, And run it&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://www.wushiyi.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Red Hat 搭建Jenkins</title>
    <link href="https://www.wushiyi.top/2020/06/02/CDCI/%E6%90%AD%E5%BB%BAJenkins/"/>
    <id>https://www.wushiyi.top/2020/06/02/CDCI/%E6%90%AD%E5%BB%BAJenkins/</id>
    <published>2020-06-02T04:10:03.000Z</published>
    <updated>2022-03-26T11:38:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>在Red Hat上从0到1搭建Jenkins</p><span id="more"></span><h1 id="Red-Hat搭建Jenkins"><a href="#Red-Hat搭建Jenkins" class="headerlink" title="Red Hat搭建Jenkins"></a>Red Hat搭建Jenkins</h1><h3 id="1-安装JDK、Git、Maven"><a href="#1-安装JDK、Git、Maven" class="headerlink" title="1.安装JDK、Git、Maven"></a>1.安装JDK、Git、Maven</h3><h3 id="2-安装Jenkins"><a href="#2-安装Jenkins" class="headerlink" title="2.安装Jenkins"></a>2.安装Jenkins</h3><h4 id="1-添加Jenkins的repo源"><a href="#1-添加Jenkins的repo源" class="headerlink" title="1.添加Jenkins的repo源"></a>1.添加Jenkins的repo源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br></pre></td></tr></table></figure><h4 id="2-导入密钥"><a href="#2-导入密钥" class="headerlink" title="2.导入密钥"></a>2.导入密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><h4 id="3-yum安装Jenkins"><a href="#3-yum安装Jenkins" class="headerlink" title="3.yum安装Jenkins"></a>3.yum安装Jenkins</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure><h4 id="4-启动Jenkins"><a href="#4-启动Jenkins" class="headerlink" title="4.启动Jenkins"></a>4.启动Jenkins</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service jenkins start</span><br></pre></td></tr></table></figure><h4 id="5-初始化Jenkins"><a href="#5-初始化Jenkins" class="headerlink" title="5.初始化Jenkins"></a>5.初始化Jenkins</h4><ol><li>打开jenkins页面（默认port为8080)</li><li>使用默认密码登录（cat /var/lib/jenkins/secrets/initialAdminPassword）</li><li>安装插件（默认安装即可）；安装完成后即可</li></ol><h4 id="6-设置Jenkins"><a href="#6-设置Jenkins" class="headerlink" title="6.设置Jenkins"></a>6.设置Jenkins</h4><ol><li>在 /系统管理/全局工具配置<ul><li>配置Maven、Git、JDK</li></ul></li><li> 打开 /系统管理/系统配置</li></ol><ul><li>Maven ops</li><li>Jenkins启动路径</li><li>Git Parameter</li><li>Git plugin配置全局user信息</li><li>Publish over ssh 配置ssh公钥、服务器地址、用户名等</li></ul><ol start="3"><li></li></ol><h4 id="7-配置部署Git项目的一些插件"><a href="#7-配置部署Git项目的一些插件" class="headerlink" title="7.配置部署Git项目的一些插件"></a>7.配置部署Git项目的一些插件</h4><p>首先先安装几个必须用到的插件</p><ul><li><a href="https://plugins.jenkins.io/git-parameter">Git Parameter Plug-In</a>](<a href="https://plugins.jenkins.io/workflow-aggregator">https://plugins.jenkins.io/workflow-aggregator</a>)</li><li><a href="https://plugins.jenkins.io/pipeline-maven">Pipeline Maven Integration Plugin</a></li><li><a href="https://plugins.jenkins.io/publish-over-ssh">Publish Over SSH</a></li><li><a href="https://plugins.jenkins.io/ssh">SSH plugin</a></li></ul><h4 id="8-配置项目与插件"><a href="#8-配置项目与插件" class="headerlink" title="8. 配置项目与插件"></a>8. 配置项目与插件</h4><ol><li>新建一个maven项目，</li><li>在Maven Info Plugin Configuration配置log rotation</li><li>添加<code>git parameter</code>配置，并增加对应的BRANCH变量名</li><li>在源码管理tab，填好对应的git地址</li><li>在编译tab中，填好maven编译指令，例如：<code>mvn clean install -pl xxx -am -Pdev -Dmaven.test.skip=true</code></li><li>也在同一tab中，在Post Steps中点击add post-build step，选择send file or exec command over SSH，此时会跳出一个SSH面板，在上面填好相应的编译前置、编译后置、编译完成后执行等指令即可</li><li>到此结束配置，可以回到Jenkins首页选择项目进行部署了</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Red Hat上从0到1搭建Jenkins&lt;/p&gt;</summary>
    
    
    
    <category term="Workflow" scheme="https://www.wushiyi.top/categories/Workflow/"/>
    
    
    <category term="Workflow" scheme="https://www.wushiyi.top/tags/Workflow/"/>
    
    <category term="CD/CI" scheme="https://www.wushiyi.top/tags/CD-CI/"/>
    
  </entry>
  
  <entry>
    <title>Springboot接入Redis</title>
    <link href="https://www.wushiyi.top/2020/02/28/Java/Spring/%E6%8E%A5%E5%85%A5Redis/"/>
    <id>https://www.wushiyi.top/2020/02/28/Java/Spring/%E6%8E%A5%E5%85%A5Redis/</id>
    <published>2020-02-28T01:54:01.000Z</published>
    <updated>2022-03-26T11:38:26.764Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot接入Redis</p><span id="more"></span><h3 id="Springboot配置Redis"><a href="#Springboot配置Redis" class="headerlink" title="Springboot配置Redis"></a>Springboot配置Redis</h3><p>如果代码需要区分不通组件的配置，可以新建一个配置，名称风格可以和spring的统一，比如<code>application-redis.properties</code>或者<code>application-redis.yml</code>，然后在spring基础配置里加上<code>spring.profiles.include=redis</code></p><p>如不需要区分，可以直接把配置信息贴到spring基础配置文件里，下面是一些常用配置（此处配置为<code>Jedis</code>，也可以选用SpringBoot 1.5之后的<code>lettuce</code>）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis配置</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0，集群状态只有一个）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis集群模式，host:port  用,隔开</span></span><br><span class="line"><span class="comment">#spring.redis.cluster.nodes=</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">xxx</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#以下为配置jedis链接池</span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-active</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-wait</span>=<span class="string">10000</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后可以进行可选配置，比如配置@Cacheable注解、配置序列化器等，这时候可以用代码配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 <span class="doctag">@Cacheable</span> 缓存注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory Thread-safe factory of Redis connections.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CacheManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RedisCacheWriter</span> <span class="variable">redisCacheWriter</span> <span class="operator">=</span> RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory);</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">defaultCacheConfig</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">//设置默认超过期时间是5分钟</span></span><br><span class="line">        defaultCacheConfig.entryTtl(Duration.ofMinutes(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisCacheWriter, defaultCacheConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 配置序列化器（使用Jackson，也可以用Fastjson之类的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplateObject</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        template.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也可以配置string操作模板，比较简单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisConnectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@Bean(&quot;stringRedisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplateObject</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用功能封装RedisUtil"><a href="#常用功能封装RedisUtil" class="headerlink" title="常用功能封装RedisUtil"></a>常用功能封装RedisUtil</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;String&gt; lockLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisScript&lt;Long&gt; releaseLockScript;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RELEASE_LOCK_LUA_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置解锁lua脚本</span></span><br><span class="line">        releaseLockScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(RELEASE_LOCK_LUA_SCRIPT, Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="meta">@NotNull</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NotNull</span> String key, Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNoneBlank(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JacksonUtils.fromJson(value, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setForExpire(key, data, <span class="number">2</span>, TimeUnit.HOURS);</span><br><span class="line">        log.info(<span class="string">&quot;save redis cache key=&#123;&#125; done value=&#123;&#125;&quot;</span>, key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setForExpire</span><span class="params">(String key, T data, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> JacksonUtils.toJson(data);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">exists</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Long <span class="title function_">ttl</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock(key, GLOBAL_LOCK_VALUE, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">lock</span><span class="params">(String key, String value, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.expire(key, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSequenceNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//14位当前时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentDateString</span> <span class="operator">=</span> DateUtils.dateToString(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">8</span>);</span><br><span class="line">        Long value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = <span class="built_in">this</span>.increment(ID_NUM_KEY_PREFIX + currentDateString);</span><br><span class="line">            <span class="built_in">this</span>.expire(ID_NUM_KEY_PREFIX + currentDateString, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;redis 请求失败!&quot;</span>, e);</span><br><span class="line">            value = Long.valueOf(RandomStringUtils.randomNumeric(<span class="number">6</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">restSeat</span> <span class="operator">=</span> NO_LIMIT - currentDateString.length();</span><br><span class="line">        <span class="keyword">return</span> currentDateString + StringUtils.leftPad(String.valueOf(value), restSeat, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIdNum</span><span class="params">(BusinessNoPrefixEnum prefixEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefixEnum.getPrefix() + getIdNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">increment</span><span class="params">(<span class="meta">@NotEmpty</span> String key)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">incr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(key);</span><br><span class="line">        <span class="keyword">return</span> incr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getSpinLock</span><span class="params">(String key, <span class="type">long</span> timeout, <span class="type">int</span> retryTimes, <span class="type">long</span> sleepTime)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!lock(key, uuid, timeout, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retryTimes == count.incrementAndGet()) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;获取分布式锁失败，获取次数达到限制。 threadName:&#123;&#125;, key:&#123;&#125;, count:&#123;&#125;, retryTimes:&#123;&#125;&quot;</span>, Thread.currentThread().getName(), key, count, retryTimes);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;获取分布式锁失败，等待自旋获取。 threadName:&#123;&#125;, key:&#123;&#125;, count:&#123;&#125;, retryTimes:&#123;&#125;&quot;</span>, Thread.currentThread().getName(), key, count, retryTimes);</span><br><span class="line">                Thread.sleep(sleepTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;线程等待出现异常&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lockLocal.set(uuid);</span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁成功。 threadName:&#123;&#125;, key:&#123;&#125;, count:&#123;&#125;, retryTimes:&#123;&#125;&quot;</span>, Thread.currentThread().getName(), key, count, retryTimes);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockSpinLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从ThreadLocal取到加锁的uuid</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> lockLocal.get();</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 参数一：redisScript，参数二：key列表，参数三：arg（可多个）</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(releaseLockScript, Collections.singletonList(key), uuid);</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(result)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;调用lua脚本解锁失败, key:&#123;&#125;, value:&#123;&#125;, threadName:&#123;&#125;&quot;</span>, key, uuid, threadName);</span><br><span class="line">                remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;调用lua脚本解锁失败, key:&#123;&#125;, value:&#123;&#125;, threadName:&#123;&#125;, e:&#123;&#125;&quot;</span>, key, uuid, threadName, e);</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lockLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SpringBoot接入Redis&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://www.wushiyi.top/tags/JAVA/"/>
    
    <category term="Spring" scheme="https://www.wushiyi.top/tags/Spring/"/>
    
    <category term="Springboot" scheme="https://www.wushiyi.top/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>几种排序实现</title>
    <link href="https://www.wushiyi.top/2020/02/14/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.wushiyi.top/2020/02/14/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-02-14T12:28:03.000Z</published>
    <updated>2022-03-26T11:38:26.772Z</updated>
    
    <content type="html"><![CDATA[<p>Insert、Select、Merge、HeapSort…</p><span id="more"></span><h4 id="排序模板"><a href="#排序模板" class="headerlink" title="排序模板"></a>排序模板</h4><p>排序中大量用到了如比较、交换、检查是否排序完成等操作，可以先抽象一个模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> comparable : arr) &#123;</span><br><span class="line">            System.out.print(comparable + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isSorted</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(arr[i], arr[i-<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort(arr);</span><br><span class="line">        show(arr);</span><br><span class="line">        System.out.println(isSorted(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li>原理：首先，找到数组中最下的元素，将最小的元素和第一个元素交换。再次，将剩下元素中最小的元素和第二个元素交换，以此类推。</li><li>时间复杂度：(N-1) + (N-2) + … + 2 + 1 ~ N^2/2 = O(N^2)</li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareSort</span> <span class="keyword">extends</span> <span class="title class_">AbstractSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(arr[j], arr[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exchange(arr, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>&#125;;</span><br><span class="line">        <span class="type">AbstractSort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareSort</span>();</span><br><span class="line">        sort.check(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li>原理:首先从右往左遍历，判断第N个与第N-1个元素大小，若第N个小于第N-1，则互换位置。</li><li>时间复杂度：平均(N^2/4), 最坏(N^2/2),最好(N-1)。 最坏即为 O(N^2)</li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> <span class="keyword">extends</span> <span class="title class_">AbstractSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(arr[j],arr[j-<span class="number">1</span>])) &#123;</span><br><span class="line">                    exchange(arr, j, j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li>原理：插入排序对于大规模乱序的数组排序很慢，因为它之后交换相邻的元素，元素只能一个一个交换位置。希尔排序的思想是使数组中任意间隔h的元素都是有序的，每次以一个有序序列进行排序，并将间隔递减实现最终的整理。</li><li>时间复杂度：约O(N^3/2)</li><li>实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> <span class="keyword">extends</span> <span class="title class_">AbstractSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h ; j = j - h) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (less(arr[j], arr[j - h])) &#123;</span><br><span class="line">                        exchange(arr, j, j-h);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul><li><p>时间复杂度(O(Log(N)))</p></li><li><p>实现</p></li><li><p>```java<br>public class MergeSort extends AbstractSort {</p><pre><code>private int[] aux;@Overridepublic void sort(int[] arr) &#123;    aux = new int[arr.length];    sort(arr, 0, arr.length - 1);&#125;private void sort(int[] arr, int low, int high) &#123;    //将【low，high】 排序    if (high &lt;= low) return;    int mid = low + (high - low) / 2;    sort(arr, low, mid);    sort(arr, mid+1, high);    merge(arr, low, mid, high);&#125;private void merge(int[] arr, int low, int mid, int high) &#123;    //将 【low， mid】、【mid+1， high】排序    int i = low, j = mid + 1;    for (int k = low; k &lt;= high; k++) &#123;        aux[k] = arr[k];    &#125;    for (int k = low; k &lt;= high; k++) &#123;        if (i &gt; mid) &#123;            arr[k] = aux[j++];        &#125; else if (j &gt; high) &#123;            arr[k] = aux[i++];        &#125; else if (less(aux[j], aux[i])) &#123;            arr[k] = aux[j++];        &#125; else &#123;            arr[k] = aux[i++];        &#125;    &#125;&#125;protected boolean less(int a, int b) &#123;    return a &lt; b;&#125;public static void main(String[] args) &#123;    int[] arr = new int[] &#123;4,7,2,5,1,9,8,3,6,0,11,10,14,13,12&#125;;    AbstractSort compareSort = new MergeSort();    compareSort.check(arr);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 快速排序</span><br><span class="line"></span><br><span class="line">- 时间复杂度(O(Log(N)))</span><br><span class="line"></span><br><span class="line">- 实现</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public class QuickSort extends AbstractSort &#123;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void sort(int[] arr) &#123;</span><br><span class="line">          sort(arr, 0, arr.length - 1);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      private void sort(int[] arr, int low, int high) &#123;</span><br><span class="line">          if (low &gt;= high) return;</span><br><span class="line">          int j = partition(arr, low, high);</span><br><span class="line">          sort(arr, low, j -1);</span><br><span class="line">          sort(arr, j + 1, high);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      private int partition(int[] arr, int low, int high) &#123;</span><br><span class="line">          //将数组切分为a[low... i-1], a[i], a[i+1...high]</span><br><span class="line">          int i = low, j = high+1;</span><br><span class="line">          int v = arr[i];</span><br><span class="line">  </span><br><span class="line">          while (true) &#123;</span><br><span class="line">              while (less(arr[++i], v)) &#123;</span><br><span class="line">                  if (i == high) break;</span><br><span class="line">              &#125;</span><br><span class="line">              while (less(v, arr[--j])) &#123;</span><br><span class="line">                  if (j == low) break;</span><br><span class="line">              &#125;</span><br><span class="line">              if (i &gt;= j) break;</span><br><span class="line">              exchange(arr, i, j);</span><br><span class="line">          &#125;</span><br><span class="line">          exchange(arr, low, j);</span><br><span class="line">          return j;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    protected boolean less(int a, int b) &#123;</span><br><span class="line">          return a &lt; b;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      protected void exchange(int[] arr, int a, int b) &#123;</span><br><span class="line">          int temp = arr[a];</span><br><span class="line">          arr[a] = arr[b];</span><br><span class="line">          arr[b] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          int[] arr = new int[] &#123;4,7,2,5,1,9,8,3,6,0,11,10,14,13,12&#125;;</span><br><span class="line">          AbstractSort compareSort = new QuickSort();</span><br><span class="line">          compareSort.check(arr);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>原理： 利用二叉堆每次新增元素时，自动上浮或下沉元素，形成一个有序的集合。</li><li>时间复杂度(O(Log(N)))</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Insert、Select、Merge、HeapSort…&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://www.wushiyi.top/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://www.wushiyi.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>READ ---《编程珠玑》</title>
    <link href="https://www.wushiyi.top/2019/12/08/Reading/%E8%AF%BB%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B/"/>
    <id>https://www.wushiyi.top/2019/12/08/Reading/%E8%AF%BB%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B/</id>
    <published>2019-12-08T08:10:03.000Z</published>
    <updated>2022-03-26T11:38:26.769Z</updated>
    
    <content type="html"><![CDATA[<p>总是听同事推荐，今天也买了本学习看看</p><span id="more"></span><h4 id="1-排序电话号码"><a href="#1-排序电话号码" class="headerlink" title="1.排序电话号码"></a>1.排序电话号码</h4><p>一个文件包含有一千万条数据，每条数据都是7位数字，不用考虑磁盘大小，如何才能在1Mb的内存中尽量快的完成排序呢？</p><ul><li>基于磁盘的归并排序，由于内存大小原因，可能需要好几天才能排序完，并且需要使用中间文件。</li><li>分趟进行排序，比如1Mb存储250000个号码，每次将排序好的号码输出到磁盘文件中，只要进行40次IO排序即可完成</li></ul><blockquote><p>那有没有不使用中间文件，且只要读取一次文件的排排序呢？</p></blockquote><p>可以使用位图或者位向量来表示集合，比如表达一个集合<code>&#123;2、5、8、12、16&#125;</code>，就可以用:</p><p><code> 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 0 1</code>来表达，有数值的部分即为1</p><h5 id="解决方案（Java实现）"><a href="#解决方案（Java实现）" class="headerlink" title="解决方案（Java实现）"></a>解决方案（Java实现）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] bitmap = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化位图，每位默认为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = bitmap.length; i &lt; len; i++) &#123;</span><br><span class="line">            bitmap[i] = (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文件，并将位图对应下标修改</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/xxx/Desktop/input.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        inputChannel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            bitmap[(<span class="type">int</span>) buffer.get()] = (<span class="type">byte</span>) <span class="number">0x01</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/xxx/Desktop/output.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FileChannel</span> <span class="variable">outputChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = bitmap.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap[i] == <span class="number">0x01</span>) buffer.put((<span class="type">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        outputChannel.write(buffer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总是听同事推荐，今天也买了本学习看看&lt;/p&gt;</summary>
    
    
    
    <category term="READ" scheme="https://www.wushiyi.top/categories/READ/"/>
    
    
    <category term="READ" scheme="https://www.wushiyi.top/tags/READ/"/>
    
    <category term="CODE" scheme="https://www.wushiyi.top/tags/CODE/"/>
    
  </entry>
  
  <entry>
    <title>表、字段、索引设计规范</title>
    <link href="https://www.wushiyi.top/2019/11/18/SQL/%E8%A1%A8%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>https://www.wushiyi.top/2019/11/18/SQL/%E8%A1%A8%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</id>
    <published>2019-11-18T10:21:00.000Z</published>
    <updated>2022-03-26T11:38:26.770Z</updated>
    
    <content type="html"><![CDATA[<p>一些数据库设计规范</p><span id="more"></span><h3 id="一-库表命名规范"><a href="#一-库表命名规范" class="headerlink" title="一.库表命名规范"></a>一.库表命名规范</h3><ol><li>库名必须有固定的命名长度，12个字符以内 ,  表名、字段名20个字符以内，需见名知意</li><li>表名字段名使用单数的英文单词，多个单词使用 _ 符号连接</li><li>库名、表名、字段名禁使用MySQL保留字</li><li>临时库、表名必须以<code>tmp</code>为前缀，并以日期为后缀</li></ol><h3 id="二-库、表、字段开发设计规范"><a href="#二-库、表、字段开发设计规范" class="headerlink" title="二.库、表、字段开发设计规范"></a>二.库、表、字段开发设计规范</h3><ol><li>原则上禁用分区表</li><li>拆分大字段和访问频率低的字段，分离冷热数据</li><li>用Hash进行分表，表名后缀使进制数</li><li>按日期时间分表需符合<code>YYYY[MM][DD][HH]</code>格式</li><li>尽可能不使用<code>TEXT</code>、<code>BLOB</code>类型,尽量使用<code>varchar</code>类型，实在避免不了，请拆表</li><li>用<code>DECIMAL</code>代替<code>FLOAT</code>和<code>DOUBLE</code>存储精确浮点数</li><li>所有字段均定义为<code>NOT NULL</code>，默认值，整型为<code>0</code>、字符串为空字符’’ ，字段需要建索引的必须用<code>NOT NULL</code>、<code> NULL</code>字段很难查询优化，<code>NULL</code>字段的索引需要额外空间</li><li>大表使用<code>bigint unsigned</code> 作为自增列</li><li>使用<code>timestamp</code>存储时间</li><li>禁止在数据库中存储明文密码，把密码加密后存储</li><li>尽量使用数值类型字段替代字符串类型</li><li>不允许使用<code>ENUM</code>，<code>ENUM</code>字段加类型是<code>DDL</code>操作，使用<code>TINYINT</code>来代替<code>ENUM</code>类型</li><li>尽量使用<code>varchar</code>存储字符串。<code>VARCHAR(M)</code>，<code>M</code>尽可能小，因为<code>VARCHAR</code>按实际的字符数申请内存时，如果大于255个，需要2bytes，小于 等于255个，需要1bytes。M表示字符数而不是字节数，比如<code>VARCHAR(1024)</code>，最大可存储1024个汉字，根据实际业务选择长度M</li></ol><h3 id="三-索引规范"><a href="#三-索引规范" class="headerlink" title="三.索引规范"></a>三.索引规范</h3><h4 id="1-索引的数量要控制"><a href="#1-索引的数量要控制" class="headerlink" title="1. 索引的数量要控制:"></a>1. 索引的数量要控制:</h4><ol><li><p>单张表中索引数量不超过8个</p></li><li><p>单个索引中的字段数不超过4个</p></li><li><p>对字符串优先考虑使用前缀索引，前缀索引长度不超过10个字符</p></li></ol><h4 id="2-主键准则"><a href="#2-主键准则" class="headerlink" title="2. 主键准则"></a>2. 主键准则</h4><ol><li><p>表必须有主键</p></li><li><p>不使用更新频繁的列作为主键</p></li><li><p>尽量不选择字符串列作为主键</p></li><li><p>不使用<code>UUID</code>、<code>MD5</code>、<code>HASH</code>这些作为主键(数值太离散了)</p></li><li><p>默认使<code>非空的唯一键</code>作为主键</p></li><li><p>建议选择自增或发号器</p></li></ol><h4 id="3-重要的SQL必须被索引，比如"><a href="#3-重要的SQL必须被索引，比如" class="headerlink" title="3. 重要的SQL必须被索引，比如:"></a>3. 重要的SQL必须被索引，比如:</h4><ol><li><p><code>UPDATE</code>、<code>DELETE</code>语句的<code>WHERE</code>条件列</p></li><li><p><code>ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code>的字段</p></li></ol><h4 id="4-多表JOIN的字段注意以下"><a href="#4-多表JOIN的字段注意以下" class="headerlink" title="4. 多表JOIN的字段注意以下:"></a>4. 多表JOIN的字段注意以下:</h4><ol><li><p>区分度最大的字段放在前面</p></li><li><p>优先考虑覆盖索引</p></li><li><p>避免冗余和重复索引</p></li><li><p>索引要综合评估数据密度和分布以及考虑查询和更新比例</p></li></ol><h4 id="5-索引禁忌"><a href="#5-索引禁忌" class="headerlink" title="5. 索引禁忌"></a>5. 索引禁忌</h4><ol><li><p>不在低基数列上建立索引，例如“性别”</p></li><li><p>不在索引列进行数学运算和函数运算</p></li></ol><h4 id="6-不使用外键"><a href="#6-不使用外键" class="headerlink" title="6. 不使用外键"></a>6. 不使用外键</h4><ol><li><p>外键用来保护参照完整性，可在业务端实现</p></li><li><p>对父表和子表的操作会相互影响，降低可用性</p></li><li><p>增加锁冲突的概率</p></li><li><p>增加写入和更新的延迟</p></li></ol><h4 id="7-索引命名"><a href="#7-索引命名" class="headerlink" title="7. 索引命名:"></a>7. 索引命名:</h4><p>非唯一索引必须以 idx_字段1_字段2命名，唯一所以必须以<code>uniq_字段1_字段2</code>命名，索引名称必须全部小写</p><h4 id="8-索引字段："><a href="#8-索引字段：" class="headerlink" title="8. 索引字段："></a>8. 索引字段：</h4><p>默认值不能为NULL，要改为其他的<code>default</code>或者空。NULL非常影响索引的查询效率</p><h4 id="9-索引最左匹配原则"><a href="#9-索引最左匹配原则" class="headerlink" title="9. 索引最左匹配原则"></a>9. 索引最左匹配原则</h4><p>反复查看与表相关的SQL，符合最左前缀的特点建立索引。多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少 索引数量</p><h4 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h4><ul><li><p>能使用唯一索引就要使用唯一索引，提高查询效率</p></li><li><p>多使用<code>explain</code>观察SQL的执行计划，如果发现索引选择性差，必须学会使用<code>hint</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些数据库设计规范&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.wushiyi.top/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.wushiyi.top/tags/Mysql/"/>
    
    <category term="workflow" scheme="https://www.wushiyi.top/tags/workflow/"/>
    
  </entry>
  
</feed>
